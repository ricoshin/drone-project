<html>
<head>
  <title>[ROS] 메세지 핸들러 매개변수 관련</title>
  <basefont face="나눔고딕" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303244 (ko-KR, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 나눔고딕;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1550"/>
<h1>[ROS] 메세지 핸들러 매개변수 관련</h1>

<div><span><div>template&lt;class M &gt;</div><table style="width:100%;"><tbody><tr><td><table style="width:100%;"><tbody><tr><td><div><a href="http://docs.ros.org/api/roscpp/html/classros_1_1Publisher.html">Publisher</a> ros::NodeHandle::advertise</div></td><td>(</td><td>const std::string &amp; </td><td><em>topic</em>,</td></tr><tr><td><br/></td><td><br/></td><td>uint32_t </td><td><em>queue_size</em>,</td></tr><tr><td><br/></td><td><br/></td><td>const <a href="http://docs.ros.org/api/roscpp/html/namespaceros.html#ac61b99a2913cd421fb915395a67e71a1">SubscriberStatusCallback</a> &amp; </td><td><em>connect_cb</em>,</td></tr><tr><td><br/></td><td><br/></td><td>const <a href="http://docs.ros.org/api/roscpp/html/namespaceros.html#ac61b99a2913cd421fb915395a67e71a1">SubscriberStatusCallback</a> &amp; </td><td><em>disconnect_cb</em> = <code><a href="http://docs.ros.org/api/roscpp/html/namespaceros.html#ac61b99a2913cd421fb915395a67e71a1">SubscriberStatusCallback</a>()</code>,</td></tr><tr><td><br/></td><td><br/></td><td>const <a href="http://docs.ros.org/api/roscpp/html/namespaceros.html#a13b47f9c38567244790a85e74e4a147d">VoidConstPtr</a> &amp; </td><td><em>tracked_object</em> = <code><a href="http://docs.ros.org/api/roscpp/html/namespaceros.html#a13b47f9c38567244790a85e74e4a147d">VoidConstPtr</a>()</code>,</td></tr><tr><td><br/></td><td><br/></td><td>bool </td><td><em>latch</em> = <code>false</code> </td></tr><tr><td><br/></td><td>)</td></tr></tbody></table></td></tr></tbody></table><div><br/></div><div><br/></div><div>void MyClass::connectCallback(const ros::SingleSubscriberPublisher&amp; pub)</div><div>     {<br/>
     // Do something<br/>
     }<br/><br/>
     MyClass my_class;</div><div>     ros::Publisher pub = handle.advertise&lt;std_msgs::Empty&gt;(&quot;my_topic&quot;, 1, <span style="color: rgb(255, 70, 53);">boost::bind(&amp;MyClass::connectCallback, my_class, _1)</span>);</div><div><br/></div><div><br/></div><div><span style="color: rgb(255, 0, 0);">*advertise : 알리다.. 알도록 하다.. 라는 뉘앙스. 마스터 노드에 등록함으로써 구독자가 알 수 있도록 발행사실을 알리다. </span></div><div><br/></div><div><b>\param topic</b></div><div>발행할 토픽</div><div><br/></div><div><b>\param queue_size</b></div><div>구독자에게 보내기 위한 메세지 발송 대기열의 최대 메세지 숫자</div><div><br/></div><div><b>\param connect_cb</b></div><div>구독자가 연결이 이루어졌을때 호출할 함수 (콜백)</div><div><br/></div><div><b>\param disconnect_cb (optional)</b></div><div>구독자와 연결이 종료되었을때 호출할 함수</div><div><br/></div><div><b>\param tracked_object (optional)</b></div><div>A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object, and if the reference count goes to 0 the subscriber callbacks will not get called.</div><div>Note that setting this will cause a new reference to be added to the object before the callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore thread) that the callback is invoked from.</div><div><br/></div><div>콜백을 추적하기 위한 객체를 가리키는 shared_ptr. 만약 이 것이 설정되면, 이 객체에 weak_ptr가 생성되고 만약 레퍼런스 카운트가 0이 되면, 구독자 콜백이 호출되지 않는다.</div><div>이 포인터를 세팅하면 콜백에 앞서 객체의 새로운 레퍼런스를 생성하고, 레퍼런스가 콜백이 호출된 코드 경로(스레드)안의 범위를 벗어나도록(잠재적으로는 삭제되도록) 해준다. <span style="color: rgb(50, 135, 18);">&lt;- weak_ptr의 기능 설명한듯.</span></div><div><br/></div><div><b><span style="color: rgb(255, 0, 0);">-&gt; 노드(this가 가리키는 것?)를 참조하는 레퍼런스가 하나도 없으면 콜백을 호출하지 않도록 하는 역할?!</span></b></div><div><br/></div><div><span style="color: rgb(222, 87, 0);">*shared_ptr은 특정 자원을 가리키는 참조 카운트를 유지하고 있다가 이것이 0 이 되면 해당 자원을 자동으로 삭제해 주는 스마트 포인터.</span></div><div><span style="color: rgb(222, 87, 0);">참조 카운트는 이를 가리키는 외부 객체의 수가 증가할 때 같이 올라간다. 즉, shared_ptr의 복사나 대입이 발생하면 레퍼런스 카운트가 증가하고, </span></div><div><span style="color: rgb(222, 87, 0);">그 복사/대입되었던 녀석들이 소멸되게 되면 레퍼런스 카운트가 감소하는 것이다.</span></div><div><span style="color: rgb(222, 87, 0);"><br/></span></div><div><span style="color: rgb(222, 87, 0);">shared_ptr은 자신이 참조하고 있는 객체(메모리 주소)에 대해 reference counting을 함으로써, 객체의 수명에 직접적으로 관여한다.</span></div><div><span style="color: rgb(222, 87, 0);">shared_ptr 객체 하나가 소멸되더라도, 동일한 메모리 주소를 참조하고 있는 다른 shared_ptr 객체가 있으면 참조하고 있던 메모리 주소의 객체는 소멸되지 않는다.</span></div><div><span style="color: rgb(222, 87, 0);"><br/></span></div><div><span style="color: rgb(222, 87, 0);">하지만, weak_ptr은 shared_ptr을 관리하기 위한 reference count에 포함되지 않는다.  즉, shared_ptr의 객체만 참조할 뿐, shared_ptr의 reference count를 올리지 않는 것이다.</span></div><div><span style="color: rgb(222, 87, 0);"><br/></span></div><div><span style="color: rgb(222, 87, 0);">사실 weak_ptr이 shared_ptr을 참조할 때 shared_ptr의 weak reference count는 증가시킨다.</span></div><div><span style="color: rgb(222, 87, 0);">객체의 생명 주기에 관여하는 strong reference count를 올리지 않는 것 뿐이다.</span></div><div><span style="color: rgb(222, 87, 0);">(shared_ptr, weak_ptr 객체를 디버거로 살펴보면 strong/weak refCount가 따로 표시된다)</span></div><div><span style="color: rgb(222, 87, 0);">(weak reference count는 객체의 소멸에는 전혀 관여하지 않으니 헷갈리지 말도록!)</span></div><div><span style="color: rgb(222, 87, 0);">출처:<a href="http://sweeper.egloos.com/2826435" target="_blank"><span style="color: rgb(222, 87, 0);"><u>[TR1] shared_ptr</u></span></a></span></div><div><u><br/></u></div><div><br/></div><div><b>\param latch (optional)</b></div><div>If true, the last message published on this topic will be saved and sent to new subscribers when they connect</div><div>*latch : 걸쇠</div><div>만약 참이면 (기본값 거짓), 이 토픽에 대해 마지막으로 발행된 메시지를 저장하여 새로운 구독자가 연결될 때 보내준다.</div><div><br/></div><div><b>\return</b></div><div>On success, a Publisher that, when it goes out of scope, will automatically release a referenc on this advertisement. </div><div>On failure, an empty Publisher which can be checked with:</div><div>성공하면 발행자를 반환하고, 범위(중괄호)를 벗어나면 발행에 대한 레퍼런스를 자동으로 해제(릴리즈)할 것이다.</div><div>실패하면 빈 발행자를 반환할 것이다.</div><div><br/></div><div>다음과 같이 체크할 수 있다 : </div><div>ros::ServiceServer service = nodeHandle.advertiseService(&quot;my_service&quot;, &amp;Foo::callback, &amp;foo_object);</div><div>if (service)  // Enter if advertised service is valid<br/>
{</div><div>     ...</div><div>}</div><div><br/></div></span>
</div></body></html> 