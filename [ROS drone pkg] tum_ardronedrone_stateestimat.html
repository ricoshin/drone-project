<html>
<head>
  <title>[ROS drone pkg] tum_ardrone/drone_stateestimation</title>
  <basefont face="나눔고딕" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303244 (ko-KR, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 나눔고딕;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1541"/>
<h1>[ROS drone pkg] tum_ardrone/drone_stateestimation</h1>

<div>
<span><div align="left"><br/></div><div align="left"><br/></div><div align="left"><span style="font-family: '맑은 고딕';"><b><span style="font-size: 24px;"><span style="color: rgb(1, 1, 1);">main_stateestimation.cpp</span></span></b></span></div><div align="left"><span style="font-family: '맑은 고딕';"><span style="font-size: 11pt;"><span style="color: rgb(1, 1, 1);"><br/></span></span></span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101">#include &quot;EstimationNode.h&quot;</font></span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101">#include &quot;ros/ros.h&quot;</font></span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101">#include &quot;PTAMWrapper.h&quot;</font></span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101">#include &quot;MapView.h&quot;</font></span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101"><br/></font></span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101"><br/></font></span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101">int main(int argc, char **argv)</font></span></div><div align="left"><br/></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101">  ros::init(argc, argv, &quot;drone_stateestimation&quot;);  <span style="color: rgb(50, 135, 18);">//노드명(</span></font><span style="color: rgb(50, 135, 18);">&quot;drone_stateestimation&quot;) 초기화</span></span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101">  ROS_INFO(&quot;Started TUM ArDrone Stateestimation Node.&quot;); <span style="color: rgb(77, 206, 29);"><span style="color: rgb(50, 135, 18);">// </span></span></font><span style="color: rgb(50, 135, 18);">&quot;Started TUM ArDrone Stateestimation Node.&quot; 출력</span></span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101">  EstimationNode estimator; <span style="color: rgb(50, 135, 18);">//</span></font> <span style="color: rgb(50, 135, 18);">구조체 EstimationNode의 인스턴스 estimator 선언. </span></span><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);"><u>EstimationNode 생성자 실행</u>.</span></span></div><div align="left"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:40px;"><b><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">         EstimationNode 생성자 </span></span></b> <span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">(from EstimationNode.cpp)</span></span></div><div align="left" style="margin-left:40px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(54, 101, 238);"><br/></span></span></div><div align="left" style="margin-left:80px;"> EstimationNode::EstimationNode()</div><div align="left" style="margin-left:80px;"> {</div><div align="left" style="margin-left:80px;"> navdata_channel = nh_.resolveName(&quot;ardrone/navdata&quot;); <span style="color: rgb(50, 135, 18);">// nh_의 노드명 &quot;...&quot;을 정식주소fully-qualified name로 바꿔 각 변수에 저장</span>.<span style="color: rgb(50, 135, 18);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;">*1</span> <span style="color: rgb(50, 135, 18);"><a href="http://docs.ros.org/indigo/api/roscpp/html/classros_1_1NodeHandle.html#ac3973408abc531f82831b9a7ee638702" rev="en_rl_minimal">참고링크</a> (링크된 코드도 확인)</span></div><div style="margin-left:160px;"><span style="color: rgb(51, 102, 255);">*1 그래프 리소스 명</span></div><div style="margin-left:160px;"><span style="color: rgb(51, 102, 255);"><span style="font-family: '맑은 고딕';">노드, 토픽, 서비스, 파라미터는 총괄해 그래프 리소스graph resources로 불리며, 이들 각각은 그래프 리소스 명으로 구별됨. 그래프 리소스 명의 종류는 다음과 같음</span></span></div><div style="margin-left:160px;"><span style="color: rgb(51, 102, 255);"><span style="font-family: '맑은 고딕';">Global name: &quot;/&quot;로 시작. 이름 변환이 필요없는 풀네임으로 간주. </span><span style="font-family: '맑은 고딕';">Global name</span><span style="font-family: '맑은 고딕';">은 코드 이식성portability을 제한하기에 되도록 피하는 것이 좋음.</span></span></div><div style="margin-left:160px;"><span style="color: rgb(51, 102, 255);">Private name: &quot;~&quot;로 시작. 이름 변환시 노드명까지 네임스페이스로 붙여 변환. <span style="font-family: '맑은 고딕';">Private name</span><span style="font-family: '맑은 고딕';">은 파라미터 서버를 통해 특정 노드에 파라미터를 보낼 때 유용함. 파라미터나, 노드 기능을 통제하는govern 서비스에 종종 사용됨.</span></span></div><div style="margin-left:160px;"><span style="color: rgb(51, 102, 255);"><span style="font-family: '맑은 고딕';">Relative name: 이름변환시 노드의 디폴트 네임스페이스를 붙여 변환. 여러 소스의 노드 그룹이 합쳐질 때 이름 충돌을 막는 이점. (cf. base name은 네임스페이스 없는 이름. base name은 relative name의 하위클래스로 같은 변환규칙을 따름. 노드명을 정할 때 가장 많이 사용됨.)</span><a href="https://cse.sc.edu/~jokane/agitr/agitr-letter-names.pdf"> </a></span><span style="color: rgb(51, 102, 255);"><a href="https://cse.sc.edu/~jokane/agitr/agitr-letter-names.pdf">참고링크1</a>  <a href="http://library.isr.ist.utl.pt/docs/roswiki/Names.html"><span style="color: rgb(51, 102, 255);">참고링크2</span></a></span></div><div align="left" style="margin-left:80px;"> control_channel = nh_.resolveName(&quot;cmd_vel&quot;);</div><div align="left" style="margin-left:80px;"> output_channel = nh_.resolveName(&quot;ardrone/predictedPose&quot;);</div><div align="left" style="margin-left:80px;"> video_channel = nh_.resolveName(&quot;ardrone/image_raw&quot;);</div><div align="left" style="margin-left:80px;"> command_channel = nh_.resolveName(&quot;tum_ardrone/com&quot;);</div><div align="left" style="margin-left:80px;"> packagePath = ros::package::getPath(&quot;tum_ardrone&quot;); <span style="color: rgb(50, 135, 18);">// 패키지명 &quot;tum_ardrone&quot;의 정식패스를 변수 package에 저장 <a href="http://docs.ros.org/indigo/api/roslib/html/c++/namespaceros_1_1package.html#ae9470dd201aa4e66abb833e710d812a4" rev="en_rl_minimal">참고링크</a>​ 참조</span></div><div align="left" style="margin-left:120px;"><br/></div><div align="left" style="margin-left:80px;"> std::string val; <span style="color: rgb(50, 135, 18);">// publishFreq 설정을 위한, 스트링값 저장용 변수</span></div><div align="left" style="margin-left:80px;"> float valFloat = 0;<span style="color: rgb(50, 135, 18);"> // publishFreq 설정을 위한 (실수형) 변수</span></div><div align="left" style="margin-left:160px;"><br/></div><div align="left" style="margin-left:80px;"> predTime = ros::Duration(25*0.001); <span style="color: rgb(250, 122, 0);">// predTime의 정확한 의미? 다음 예측까지의 시간? 즉 예측 간 시간간격? <span style="color: rgb(0, 128, 0);">predTime은 ros::Duration 타입임. ros::Duration은 s, ns두 개 멤버를 갖는데, 0.025이므로 s=0, ns=25,000,000 값을 가짐.</span> <span style="color: rgb(50, 135, 18);"><span style="color: rgb(0, 128, 0);">c</span>f. </span></span><span style="color: rgb(50, 135, 18);">ros::Duration <span style="color: rgb(50, 135, 18);"><a href="http://docs.ros.org/api/rostime/html/classros_1_1Duration.html">참고링크1</a></span></span> <a href="http://docs.ros.org/api/rostime/html/classros_1_1Time.html" rev="en_rl_minimal">참고링크2</a></div><div align="left" style="margin-left:120px;"><br/></div><div align="left" style="margin-left:80px;"> ros::param::get(&quot;~publishFreq&quot;, val); <span style="color: rgb(50, 135, 18);">// 파라미터 서버로부터 스트링값을 받아옴. 파라미터 서버의 publishFreq 키의 밸류 값을 val에 저장. 파라미터값이 회수되면 true, 아니면 false 반환. <a href="http://docs.ros.org/indigo/api/roscpp/html/namespaceros_1_1param.html#a3ad13d1a117674e86cc190bda8ad2867"><span style="color: rgb(50, 135, 18);">참고링크</span></a></span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">     cf. ~로 시작하는 이름은 private. private 이름은 파라미터 서버를 통해 특정 노드에 파라미터를 전달할 때 사용됨. <a href="http://library.isr.ist.utl.pt/docs/roswiki/Names.html"><span style="color: rgb(50, 135, 18);">참고링크</span></a></span></div><div align="left" style="margin-left:80px;">if(val.size()&gt;0)</div><div align="left" style="margin-left:80px;">      sscanf(val.c_str(), &quot;%f&quot;, &amp;valFloat); <span style="color: rgb(50, 135, 18);">// val이 있으면(회수되면) val 값을 valFloat에 저장</span></div><div align="left" style="margin-left:80px;"> else </div><div align="left" style="margin-left:80px;"> valFloat = 30; <span style="color: rgb(50, 135, 18);">// val이 없으면 valFloat를 30으로 설정</span></div><div align="left" style="margin-left:80px;"> publishFreq = valFloat; <span style="color: rgb(50, 135, 18);">// valFloat를 publishFreq로 저장</span></div><div align="left" style="margin-left:80px;"> cout &lt;&lt; &quot;set publishFreq to &quot; &lt;&lt; valFloat &lt;&lt; &quot;Hz&quot;&lt;&lt; endl; <span style="color: rgb(50, 135, 18);">// publishFreq 설정 메시지 출력</span></div><div align="left" style="margin-left:120px;"><br/></div><div align="left" style="margin-left:80px;"> ros::param::get(&quot;~calibFile&quot;, calibFile); <span style="color: rgb(50, 135, 18);">// 파라미터 서버의 calibFile 키의 밸류</span> <span style="color: rgb(50, 135, 18);">값</span><span style="color: rgb(50, 135, 18);">(calibFile 이름인 듯)을 calibFile에 저장. 파라미터값이 회수되면 true, 아니면 false 반환.</span> <span style="color: rgb(50, 135, 18);">calibFile의 자료형은 std::string(calibFile 이름을 담으므로). </span></div><div align="left" style="margin-left:80px;"> if(calibFile.size()&gt;0)</div><div align="left" style="margin-left:80px;">        cout &lt;&lt; &quot;set calibFile to &quot; &lt;&lt; calibFile &lt;&lt; endl; <span style="color: rgb(50, 135, 18);">// calibFile이 있으면  calibFile 설정 메시지 출력</span></div><div align="left" style="margin-left:80px;"> else</div><div align="left" style="margin-left:80px;">        cout &lt;&lt; &quot;set calibFile to DEFAULT&quot; &lt;&lt; endl; <span style="color: rgb(50, 135, 18);">// calibFile이 없으면 calibFile을 디폴트로 설정한다는 메시지 출력</span></div><div align="left" style="margin-left:80px;"><br/></div><div align="left" style="margin-left:80px;"> navdata_sub       = nh_.subscribe(navdata_channel, 10, &amp;EstimationNode::navdataCb, this); <span style="color: rgb(0, 128, 0);">// (구독할 토픽, 최대 대기 메시지 수, 메시지가 왔을 때 호출할 멤버 함수 포인터(, 호출한 멤버 함수 적용할 대상))</span> <span style="color: rgb(0, 128, 0);">토픽 navdata_channel의 메시지를 구독하는 </span><span style="color: rgb(0, 128, 0);">서브스크라이버 navdata_sub 선언. 메시지 받으면 <span style="color: rgb(255, 102, 0);">(this에)</span> navdataCb 콜백함수 실행.</span>   <span style="color: rgb(0, 128, 0);">   <span style="color: rgb(255, 102, 0);">?? 여기서 this는 무엇??</span></span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(50, 135, 18);"><b><span style="font-family: '맑은 고딕';">  </span></b> cf.</span> <span style="color: rgb(0, 128, 0);">subscribe() 함수 : </span><span style="color: rgb(0, 128, 0);">해당 토픽에 대한 관심을 마스터에 등록하는 함수. 노드는 해당 토픽 발행자에 자동으로 연결됨. 각 메시지에 대한 응답으로 함수포인터 fp가 호출되어 받은 메시지에 공유 포인터를 전달. 해당 토픽에 대한 구독이 공유되는 한, 메시지는 바뀔 수 없음(해석 확인 필요)</span> <span style="color: rgb(0, 128, 0);"><a href="http://docs.ros.org/indigo/api/roscpp/html/classros_1_1NodeHandle.html#a317fe4c05919e0bf3fb5162ccb2f7c28" rev="en_rl_small">참고링크</a></span></div><div align="left" style="margin-left:80px;"> vel_sub = nh_.subscribe(control_channel,10, &amp;EstimationNode::velCb, this); //  <span style="color: rgb(0, 128, 0);">토픽 control_channel의 메시지를 구독하는 </span><span style="color: rgb(0, 128, 0);">서브스크라이버 vel_sub 선언. 메시지 받으면 <span style="color: rgb(255, 102, 0);">(this에)</span> velCb 콜백함수 실행</span></div><div align="left" style="margin-left:80px;">vid_sub = nh_.subscribe(video_channel,10, &amp;EstimationNode::vidCb, this); <span style="color: rgb(0, 128, 0);">// 토픽 video_channel의 메시지를 구독하는 </span><span style="color: rgb(0, 128, 0);">서브스크라이버 vid_sub 선언. 메시지 받으면 <span style="color: rgb(255, 102, 0);">(this에)</span> vidCb 콜백함수 실행</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">               </span></span></div><div style="margin-left:80px;">dronepose_pub = nh_.advertise&lt;tum_ardrone::filter_state&gt;(output_channel,1);  <span style="color: rgb(0, 128, 0);">// 토픽 output_channel의 메시지를 발행하는 퍼블리셔 dronepose_pub</span> <span style="color: rgb(0, 128, 0);">선언. 타입은 </span> <span style="color: rgb(0, 128, 0);">&lt;tum_ardrone::filter_state&gt;</span></div><div style="margin-left:40px;">          tum_ardrone_pub = nh_.advertise&lt;std_msgs::String&gt;(command_channel,50);  <span style="color: rgb(0, 128, 0);">// </span><span style="color: rgb(0, 128, 0);">토픽</span><span style="color: rgb(0, 128, 0);"> command_channel의 메시지를 발행하는 퍼블리셔 tum_ardrone_pub</span> <span style="color: rgb(0, 128, 0);">선언. 타입은 </span> <span style="color: rgb(0, 128, 0);">&lt;std_msgs::String&gt;</span></div><div style="margin-left:40px;">          tum_ardrone_sub = nh_.subscribe(command_channel,50, &amp;EstimationNode::comCb, this);  <span style="color: rgb(0, 128, 0);">// 토픽 command_channel의 메시지를 구독하는 </span><span style="color: rgb(0, 128, 0);">서브스크라이버 tum_ardron_sub 선언. 메시지 받으면 <span style="color: rgb(255, 102, 0);">(this에)</span> comCb 콜백함수 실행</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">               </span></span></div><div align="left" style="margin-left:200px;"><br/></div><div style="margin-left:80px;">//tf_broadcaster();</div><div align="left" style="margin-left:200px;"><br/></div><div style="margin-left:80px;">(다른 내부 변수들)</div><div style="margin-left:80px;">logfileIMU = logfilePTAM = logfileFilter = logfilePTAMRaw = 0;</div><div style="margin-left:80px;">currentLogID = 0;</div><div style="margin-left:80px;">lastDroneTS = 0;</div><div style="margin-left:80px;">lastRosTS = 0;</div><div style="margin-left:80px;">droneRosTSOffset = 0;</div><div style="margin-left:80px;">lastNavStamp = ros::Time(0);</div><div style="margin-left:80px;">filter = new DroneKalmanFilter(this); <span style="color: rgb(0, 128, 0);">// 클래스 DroneKalmanFilter의 인스턴스 filter(주소값) 선언.  <u>DroneKalmanFilter 생성자 실행</u></span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             -----------------------------------------------------</span></div><div style="margin-left:80px;"><u><span style="color: rgb(0, 128, 0);"><br/></span></u></div><div align="left" style="font-family: gotham, helvetica, arial, sans-serif; margin-left: 200px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;"><b>DroneKalmanFilter::DroneKalmanFilter()</b> 생성자 </span><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;"><span style="font-family: gotham, helvetica, arial, sans-serif;">(from DroneKalmanFilter.cpp)</span></span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 200px;"><span style="color: rgb(0, 128, 0);">DroneKalmanFilter::DroneKalmanFilter(EstimationNode* n)</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 200px;"><span style="color: rgb(0, 128, 0);">{</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 200px;"><span style="color: rgb(0, 128, 0);">scalePairs = new std::vector&lt;ScaleStruct&gt;();</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 200px;"><span style="color: rgb(0, 128, 0);">navdataQueue = new std::deque&lt;ardrone_autonomy::Navdata&gt;();</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 200px;"><span style="color: rgb(0, 128, 0);">velQueue = new std::deque&lt;geometry_msgs::TwistStamped&gt;();</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 200px;"><span style="color: rgb(0, 128, 0);">useScalingFixpoint = false;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 200px;"><span style="color: rgb(0, 128, 0);">this-&gt;node = n;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 200px;"><span style="color: rgb(0, 128, 0);">pthread_mutex_lock( &amp;filter_CS ); // 뮤텍스 filter_CS 잠금</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 200px;"><span style="color: rgb(0, 128, 0);">reset(); // 현재시각을 주기rate 시작시각으로 설정 </span><a href="http://docs.ros.org/jade/api/rostime/html/classros_1_1Rate.html#aa5e56b39f5d94c8cd4dc156188d6c5b9" rev="en_rl_minimal">참고링크</a> or DroneKalmanFilter::reset()</div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">----------------------------------------</span><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">---------------     </span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">void DroneKalmanFilter::reset() (from</span> <span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;"><span style="font-family: gotham, helvetica, arial, sans-serif;">DroneKalmanFilter.cpp)</span></span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">{</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">// 포즈 0(var 0), 속도 0(var large)으로 필터 초기화</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">x = y = z = yaw = PVFilter(0); // PVFilter(0)값을 x,y,z,yaw에 저장</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">// cf. class PVFilter (from. DroneKalmanFilter.h) </span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><a href="https://www.edwardrosten.com/cvd/toon/html-user/structTooN_1_1Vector.html" rev="en_rl_small">TooN 참고링크</a> <span style="color: rgb(50, 135, 18);">(어려워서 더 파고들지는 못함;)</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">// cf. class PFlilter (from. DronekalmanFilther.h)</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;">roll = pitch = PFilter(0); //PFilter(0)값을 pitch, roll에 저장</div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;">lastIMU_XYZ_ID = lastIMU_RPY_ID = -1; // -1을 lastIMU_XYZ_ID, lastIMU_RPY_ID에 저장</div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;">predictedUpToDroneTime = 0; // 0을 predictedUpTo DroneTime에 저장</div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;">last_z_heightDiff = 0; // 0을 last_z_heightdiff에 저장</div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 480px;"><br/></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">scalePairsIn = scalePairsOut = 0; // 0을 scalePairsIn과 scalePairsOut에 저장 </span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">(cf. scalePairsIn, </span> <span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">scalePairsOut은 EstimationNode.cpp의 reSendInfo()와 </span> <span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;"><span style="font-family: gotham, helvetica, arial, sans-serif;">DroneKalmanFilter.cpp에서 사용됨)</span></span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 480px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">numGoodIMUObservations = 0; // 통계적</span><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">statistic</span> <span style="color: rgb(0, 128, 0);">파라미터 </span><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">numGoodIMUObservation</span><span style="color: rgb(0, 128, 0);">를 0으로 설정.</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">// 이전 패키지가 없음을 나타낼 수 있도록 last times을 전부 0으로 설정</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">lastIMU_XYZ_dronetime = lastIMU_RPY_dronetime = 0; </span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">lastIMU_dronetime = 0;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 480px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">clearPTAM();</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">                          ----------------------------------------</span><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">---------------</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">void DroneKalmanFilter::clearPTAM()  </span> <span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">(from</span> <span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;"><span style="font-family: gotham, helvetica, arial, sans-serif;">DroneKalmanFilter.cpp)</span></span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">{</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">// 오프셋과 스케일은 초기화되지 않음</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">offsets_xyz_initialized = scale_xyz_initialized = false;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">xy_scale = z_scale = scale_from_xy = scale_from_z = 1;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">roll_offset = pitch_offset = yaw_offset = x_offset = y_offset = z_offset = 0;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 600px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">xyz_sum_IMUxIMU = 0.1;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">xyz_sum_PTAMxPTAM = 0.1;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">xyz_sum_PTAMxIMU = 0.1;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">scalePairs-&gt;clear();</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">scalePairsIn = 1;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">scalePairsOut = 0;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 600px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">rp_offset_framesContributed = 0;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 600px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">// 통계적 파라미터들을 0으로 설정</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">numGoodPTAMObservations = 0;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 600px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 360px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">                  // 마지막 PTAM 프레임이 유효하지 않음을 표시</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">lastPosesValid = false;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">} </span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">                           ----------------------------------------</span><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">---------------</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 600px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">// IMU 큐를 클리어</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">navdataQueue-&gt;clear();</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">velQueue-&gt;clear();</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 480px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">predictdUpToTimestamp = getMS(ros::Time::now()); // 현재시간(단위:ms)을 predictedUpToTimestamp에 저장</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">predictedUpToTotal = -1; </span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 480px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">baselineZ_Filter = baselineZ_IMU = -999999;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">baselinesYValid = false;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 480px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">node-&gt;publishCommand(&quot;u l EKF가 0으로 리셋되었다는 메시지 발행</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 320px;"><span style="color: rgb(0, 128, 0);">}</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0);">----------------------------------------</span><span style="color: rgb(0, 128, 0);">---------------</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0);">void EstimationNode::publishCommand(std::string c) (from EstimationNode</span><span style="color: rgb(0, 128, 0);">std_msgs::String s;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0);">s.data = c.c_str();</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0);">pthread_mutex_lock(&amp;tum_ardrone_CS);</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0);">.\publish(s);</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0);">pthread_mutex_unlock(&amp;tum_ardrone_CS);</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 640px;"><span style="color: rgb(0, 128, 0);">}</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 440px;"><span style="color: rgb(0, 128, 0);">---------------------------------------</span><span style="color: rgb(0, 128, 0);">---------------</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 280px;"><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">  ---------------------------------------</span><span style="color: rgb(0, 128, 0); font-family: gotham, helvetica, arial, sans-serif;">---------------     </span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 240px;"><span style="color: rgb(0, 128, 0);">          pthread_mutex_unlock( &amp;filter_CS ); // 뮤텍스 filter_CS 잠금해제</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 280px;"><span style="color: rgb(0, 128, 0);">c1 = 0.58; // <span style="color: rgb(255, 102, 0);">무슨 값?</span> 값 설정</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 280px;"><span style="color: rgb(0, 128, 0);">c2 = 17.8;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 280px;"><span style="color: rgb(0, 128, 0);">c3 = 10;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 280px;"><span style="color: rgb(0, 128, 0);">c4 = 35;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 160px;"><span style="color: rgb(0, 128, 0);">                              c5 = 10;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 280px;"><span style="color: rgb(0, 128, 0);">c6 = 25;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 280px;"><span style="color: rgb(0, 128, 0);">c7 = 1.4;</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 280px;"><span style="color: rgb(0, 128, 0);">c8 = 1.0</span></div><div align="left" style="font-family: &quot;Helvetica Neue&quot;, Arial, sans; margin-left: 280px;"><span style="color: rgb(0, 128, 0);">}</span></div><div style="margin-left:80px;"><u><span style="color: rgb(0, 128, 0);"><br/></span></u></div><div>                  ptamWrapper = new PTAMWrapper(filter, this); <span style="color: rgb(0, 128, 0);">// 클래스 PTAMWrapper의 인스턴스 ptamWrapper(주소값) 선언.   P<u>TAMWrapper 생성자 실행</u></span> <span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;">(cf. 인스턴스 생성시 해당 클래스의 헤더 파일에 정의된 내부 멤버 및 함수도 할당/선언됨(실행되지는 않음))</span></div><div style="margin-left:80px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">                                 -----------------------------------------------------</span></span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                       </span>  <b><span style="color: rgb(50, 135, 18);">PTAMWrapper::PTAMWrapper</span> <span style="color: rgb(0, 128, 0);">생성자</span></b><b><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);"> </span></span></b> <span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">(from PTAMWrapper.cpp)</span></span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                          PTAMWrapper::PTAMWrapper(DroneKalmanFilter* f, EstimationNode* nde)</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                          {</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             filter = f;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             node = nde;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             mpMap = 0;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             mpMapMaker = 0;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             mpTracker = 0;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             predConvert = 0;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             predIMUOnlyForScale = 0;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             mpCamera = 0;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             newImageAvailable = false;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             mapPointsTransformed = std::vector&lt;tvec3&gt;();</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             keyFramesTransformed = std::vector&lt;tse3&gt;();</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             predConvert = new Predictor();</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             predIMUOnlyForScale = new Predictor();</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             imuOnlyPred = new Predictor();</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             drawUI = UI_PRES;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             frameWidth = frameHeight = 0;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             minKFDist = 0;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             minKFWiggleDist = 0;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             minKFTimeDist = 0;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);"> <br/></span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             maxKF = 60;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                             logfileScalePairs = 0;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                              }</span></div><div style="margin-left:80px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">                      -----------------------------------------------------</span></span></div><div>               mapView = new MapView(filter, ptamWrapper, this); <span style="color: rgb(0, 128, 0);">// 클래스 MapView의 인스턴스 mapView 선언.  <u>MapView 생성자 실행</u> (cf. 인스턴스 생성시 해당 클래스의 헤더 파일에 정의된 내부 멤버 및 함수도 할당/선언됨(실행되지는 않음))</span></div><div style="margin-left:80px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">                      -----------------------------------------------------</span></span></div><div style="margin-left:80px;"><b><span style="color: rgb(50, 135, 18);">                     </span>  <span style="color: rgb(50, 135, 18);">MapView::MapView</span></b> <b><span style="color: rgb(0, 128, 0);">생성자</span></b><b><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);"> </span></span></b> <span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">(from MapView.cpp)</span></span> <span style="color: rgb(50, 135, 18);"> </span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                        MapView::MapView(DroneKalmanFilter* f, PTAMWrapper* p, EstimationNode* nde)</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                        {</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                        filter = f;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                        ptamWrapper = p;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                        node = nde;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                        drawUI = UI_PRES;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                        resetRequested = false;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                        trailPoints = std::vector&lt;TrailPoint&gt;();</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                        predConvert = new Predictor();</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                        clearTrail = false;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                        resetMapViewFlag = true;</span></div><div style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                         }</span></div><div style="margin-left:80px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">                      -----------------------------------------------------</span></span></div><div style="margin-left:40px;">     arDroneVersion = 0;</div><div>               //memset(&amp;lastNavdataReceived,0,sizeof(ardrone_autonomy::Navdata));</div><div>               }</div><div><span style="font-family: '맑은 고딕';"><span style="color: rgb(1, 1, 1);"><br/></span></span></div><div><br/></div><div><span style="font-family: '맑은 고딕';"><span style="color: rgb(1, 1, 1);"><br/></span></span></div><div><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div><div align="left"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);"><br/></span></span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101">dynamic_reconfigure::Server&lt;tum_ardrone::StateestimationParamsConfig&gt; srv; <span style="color: rgb(50, 135, 18);">//</span></font></span> <span style="font-family: '맑은 고딕';font-size:14px;"><span style="color: rgb(0, 128, 0);">클래스</span></span> <span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: '맑은 고딕';font-size:14px;">dynamic_reconfigure::Server&lt;</span> <span style="font-family: '맑은 고딕';font-size:14px;">tum_ardrone::StateestimationParamsConfig</span> <span style="font-family: '맑은 고딕';font-size:14px;">&gt;</span></span> <span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">의 인스턴스 srv 선언. </span></span> <span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: '맑은 고딕';font-size:14px;">dynamic_reconfigure/Server.h에 있는 클래스 Server. </span></span> <span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: '맑은 고딕';font-size:14px;">템플릿은 &lt;class ConfigType&gt; 형식. <a href="https://github.com/ros/dynamic_reconfigure/blob/master/include/dynamic_reconfigure/server.h">참고링크</a></span></span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101">dynamic_reconfigure::Server&lt;tum_ardrone::StateestimationParamsConfig&gt;::CallbackType f; </font><span style="color: rgb(0, 128, 0);">// 클래스</span></span> <span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';font-size:14px;">dynamic_reconfigure::Server&lt;</span> <span style="font-family: '맑은 고딕';font-size:14px;">tum_ardrone::StateestimationParamsConfig</span> <span style="font-family: '맑은 고딕';font-size:14px;">&gt;::</span><span style="font-family: '맑은 고딕';">CallbackType의 인스턴스 f 선언. </span> <span style="font-family: '맑은 고딕';font-size:14px;">dynamic_reconfigure/Server.h에 있는 클래스 Server의 private 멤버 클래스 CallbackType. </span></span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101">f = boost::bind(&amp;EstimationNode::dynConfCb, &amp;estimator, _1, _2);</font></span> <a href="http://www.boost.org/doc/libs/1_61_0/libs/bind/doc/html/bind.html" rev="en_rl_small">참고링크</a></div><div align="left"><br/></div><div align="left"><span style="color: rgb(51, 102, 255);">cf.  <a href="[ROS] dynamic_reconfigure.html" rev="en_rl_minimal" style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;"><span style="color: rgb(51, 102, 255);">[ROS] dynamic_reconfigure</span></a> 노트 참고해 간단 정리</span></div><div align="left"><span style="color: rgb(51, 102, 255);">메인문 실행 중에 파라미터 재설정을 가능하게 하기 위해 동적재설정서버 srv를 정의.</span></div><div align="left"><span style="color: rgb(51, 102, 255);">재설정 요청이 들어올 때마다 호출할 콜백변수 f 정의</span></div><div align="left"><span style="color: rgb(51, 102, 255);">콜백변수 f에 콜백함수 dynConfCb(), 콜백함수 적용대상 estimator 연결</span></div><div align="left"><span style="color: rgb(51, 102, 255);">이제 서버가 재설정 요청을 받으면 estimator에 콜백함수 dynConfCb() 호출</span></div><div align="left"><br/></div><div align="left"><span style="color: rgb(1, 1, 1);"><br/></span></div><div align="left" style="margin-left:80px;"><span style="font-family: '맑은 고딕';font-size:14px;"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">void EstimationNode::dynConfCb(tum_ardrone::StateestimationParamsConfig &amp;config, uint32_t level)</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">{</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">if(!filter-&gt;allSyncLocked &amp;&amp; config.PTAMSyncLock)</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">ROS_WARN(&quot;Ptam Sync has been disabled. This fixes scale etc.&quot;);</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);"><br/></span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">if(!ptamWrapper-&gt;mapLocked &amp;&amp; config.PTAMMapLock)</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">ROS_WARN(&quot;Ptam Map has been locked.&quot;);</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);"><br/></span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">filter-&gt;useControl =config.UseControlGains;</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">filter-&gt;usePTAM =config.UsePTAM;</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">filter-&gt;useNavdata =config.UseNavdata;</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);"><br/></span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">filter-&gt;useScalingFixpoint = config.RescaleFixOrigin;</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);"><br/></span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">ptamWrapper-&gt;maxKF = config.PTAMMaxKF;</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">ptamWrapper-&gt;mapLocked = config.PTAMMapLock;</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">filter-&gt;allSyncLocked = config.PTAMSyncLock;</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);"><br/></span></div><div align="left" style="margin-left:40px;"><span style="color: rgb(1, 1, 1);">         ptamWrapper-&gt;setPTAMPars(config.PTAMMinKFTimeDiff, config.PTAMMinKFWiggleDist, config.PTAMMinKFDist);</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);"><br/></span></div><div align="left" style="margin-left:40px;"><span style="color: rgb(1, 1, 1);">         filter-&gt;c1 = config.c1;</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">filter-&gt;c2 = config.c2;</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">filter-&gt;c3 = config.c3;</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">filter-&gt;c4 = config.c4;</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">filter-&gt;c5 = config.c5;</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">filter-&gt;c6 = config.c6;</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">filter-&gt;c7 = config.c7;</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(1, 1, 1);">filter-&gt;c8 = config.c8;</span></div><div><span style="color: rgb(1, 1, 1);">                  }</span></div><div><span style="font-family: '맑은 고딕';font-size:14px;"><span style="color: rgb(50, 135, 18);">                  -----------------------------------------------------</span></span></div><div><span style="font-family: '맑은 고딕';"><font color="#010101">srv.setCallback(f); <span style="color: rgb(50, 135, 18);">// 인스턴스 srv의, 매개변수를 f로 한 setCallback()함수 호출.</span></font></span></div><div align="left"><span style="font-family: '맑은 고딕';font-size:14px;"><span style="color: rgb(50, 135, 18);">                    -----------------------------------------------------</span></span></div><div align="left"><span style="color: rgb(50, 135, 18);">                    </span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">void setCallback(const CallbackType &amp;callback)</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">  {</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">  boost::recursive_mutex::scoped_lock lock(mutex_);</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">  callback_ = callback;</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">  callCallback(config_, ~0); // At startup we need to load the configuration with all level bits set. (Everything has changed.)</span></div><div align="left" style="margin-left:80px;"><span style="font-family: '맑은 고딕';font-size:14px;"><span style="color: rgb(50, 135, 18);">                            -----------------------------------------------------</span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(50, 135, 18);">void callCallback(ConfigType &amp;config, int level)</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(50, 135, 18);">  {</span></div><div align="left" style="margin-left:240px;"><span style="color: rgb(50, 135, 18);">  if (callback_) // At startup we need to load the configuration with all level bits set. (Everything has changed.)</span></div><div align="left" style="margin-left:240px;"><span style="color: rgb(50, 135, 18);">  try {</span> <span style="color: rgb(50, 135, 18);">callback_(config, level); </span><span style="color: rgb(50, 135, 18);">}</span></div><div align="left" style="margin-left:240px;"><span style="color: rgb(50, 135, 18);">  catch (std::exception &amp;e)</span></div><div align="left" style="margin-left:240px;"><span style="color: rgb(50, 135, 18);">  {</span><span style="color: rgb(50, 135, 18);">  ROS_WARN(&quot;Reconfigure callback failed with exception %s: &quot;, e.what());</span> <span style="color: rgb(50, 135, 18);">}</span></div><div align="left" style="margin-left:240px;"><span style="color: rgb(50, 135, 18);">  catch (...)</span></div><div align="left" style="margin-left:240px;"><span style="color: rgb(50, 135, 18);">  {</span> <span style="color: rgb(50, 135, 18);">ROS_WARN(&quot;Reconfigure callback failed with unprintable exception.&quot;);</span> <span style="color: rgb(50, 135, 18);">}</span></div><div align="left" style="margin-left:240px;"><span style="color: rgb(50, 135, 18);">  else</span></div><div align="left" style="margin-left:240px;"><span style="color: rgb(50, 135, 18);">  ROS_DEBUG(&quot;setCallback did not call callback because it was zero.&quot;); /// @todo kill this line.</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(50, 135, 18);">          }</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">                            </span> <span style="font-family: '맑은 고딕';font-size:14px;"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">  updateConfigInternal(config_);</span></div><div align="left" style="margin-left:80px;"><span style="font-family: '맑은 고딕';font-size:14px;"><span style="color: rgb(50, 135, 18);">                             -----------------------------------------------------</span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(50, 135, 18);">     void updateConfigInternal(const ConfigType &amp;config)</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(50, 135, 18);">  {</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(50, 135, 18);">  boost::recursive_mutex::scoped_lock lock(mutex_);</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(50, 135, 18);">  config_ = config;</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(50, 135, 18);">  config_.__toServer__(node_handle_);</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(50, 135, 18);">  dynamic_reconfigure::Config msg;</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(50, 135, 18);">  config_.__toMessage__(msg);</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(50, 135, 18);">  update_pub_.publish(msg);</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(50, 135, 18);">  }</span></div><div align="left" style="margin-left:200px;"><span style="font-family: '맑은 고딕';font-size:14px;"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(50, 135, 18);">  }</span></div><div align="left"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101"><br/></font></span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101">estimator.ptamWrapper-&gt;startSystem(); <span style="color: rgb(50, 135, 18);">// 인스턴스 estimator의 클래스 EstimationNode의 헤더파일에 클래스 PTAMWrapper가 선언됨.</span></font></span> <span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">인스턴스 estimator의 구조체</span></span> <span style="font-family: '맑은 고딕';"><font color="#010101"><span style="color: rgb(50, 135, 18);">EstimationNode </span></font></span><span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">멤버에 클래스 PTAMWrapper의 포인터(*)를 담을 그릇 ptamWrapper가 선언됨.</span></span></div><div align="left"><span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">(cf. ptamWrapper = new PTAMWrapper(); new는 메모리 동적할당으로 포인터를 반환함. 따라서 결과적으로 PTAMWrapper의 포인터 그릇 ptamwrapper 선언에 상응함) ptamWrapper 포인터가 가리키는 객체에 대해 startSystem() 함수 실행. </span></span></div><div align="left"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div><div align="left">                    <span style="color: rgb(0, 128, 0);"><b>PTAMWrapper::startSystem()</b></span> <span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';"><b><span style="color: rgb(0, 128, 0);">함수</span></b></span> <span style="font-family: '맑은 고딕';">(</span><span style="font-family: '맑은 고딕';">from PTAMWrapper.cpp) <span style="color: rgb(51, 102, 255);"><u><b>시스템 및 각각의 쓰레드 실행 (PTAMWrapper.h)</b></u></span></span></span></div><div align="left" style="margin-left:80px;"><span style="font-family: '맑은 고딕';">  <span style="color: rgb(0, 128, 0);">void PTAMWrapper::startSystem()</span></span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';">  {</span></span></div><div align="left" style="margin-left:40px;"><span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';">            keepRunning = true;  // </span><span style="font-family: '맑은 고딕';">void PTAMWrapper::run() 실행시 반영됨 </span><span style="font-family: '맑은 고딕';">(</span><span style="font-family: '맑은 고딕';">from PTAMWrapper.cpp)</span></span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';">   changeSizeNextRender = false; // </span> <span style="font-family: '맑은 고딕';">void PTAMWrapper::run() 실행시 true로 바뀜</span></span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';">   start(); </span></span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';">   }</span></span></div><div style="margin-left: 160px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">     -----------------------------------------------------</span></span></div><div style="margin-left: 160px;"><span style="color: rgb(50, 135, 18);"><b>     </b></span> <span style="color: rgb(0, 128, 0);"><b>start()</b> 함수</span><span style="color: rgb(0, 128, 0);"><b><span style="font-family: '맑은 고딕';"> </span></b> <span style="font-family: '맑은 고딕';">(from CVD::Thread)</span></span><span style="color: rgb(50, 135, 18);"> <span style="color: rgb(51, 102, 255);">*1.</span></span> <a href="https://www.edwardrosten.com/cvd/cvd/html/classCVD_1_1Thread.html" rev="en_rl_minimal"><span style="color: rgb(51, 102, 255);">참고링크</span></a></div><div style="margin-left: 160px;"><span style="color: rgb(51, 102, 255);">     CVD: 빠른 비디오 저장, 로딩, 디스플레이를 위한 이식성 좋고 사용하기 쉬운 C++ 라이브러리. OpendGL, X Windows 지원. <br/></span></div><div style="margin-left: 160px;"><span style="color: rgb(51, 102, 255);"><span style="font-family: '맑은 고딕';">     CVD::Thread : 실행 쓰레드를 캡슐화하는encapsulates 쓰레드 클래스. POSIX 쓰레드(pthread)를 구현implemented. 이 클래스를 사용하는 코드는 (nanosleep을 쓰기 위해) libpthread와 librt와 링크되어야 함.</span></span></div><div style="margin-left: 160px;"><span style="color: rgb(0, 128, 0);">     void start(Runnable * runnable=0)</span></div><div style="margin-left: 160px;"><span style="color: rgb(0, 128, 0);">                             </span> <span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">-</span></span><span style="color: rgb(50, 135, 18);">----------------------------------------------------</span></div><div style="margin-left: 160px;"><span style="color: rgb(0, 128, 0);">                              class Runnable</span></div><div style="margin-left:280px;"><span style="color: rgb(0, 128, 0);">{</span></div><div style="margin-left:280px;"><span style="color: rgb(0, 128, 0);"> public:</span></div><div style="margin-left:280px;"><span style="color: rgb(0, 128, 0);">virtual void run()=0; <span style="color: rgb(255, 102, 0);">??의미??</span></span></div><div style="margin-left:280px;"><span style="color: rgb(0, 128, 0);">virtual ~Runnable(){};</span></div><div style="margin-left:280px;"><span style="color: rgb(0, 128, 0);">};</span></div><div style="margin-left: 240px;"><span style="color: rgb(0, 128, 0);">         </span><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">-</span></span><span style="color: rgb(50, 135, 18);">---------------------------------------------------</span></div><div style="margin-left:120px;"><span style="color: rgb(0, 128, 0);">             </span> <span style="color: rgb(0, 128, 0);">  </span></div><div><span style="font-family: '맑은 고딕';"><font color="#010101"> estimator.mapView-&gt;startSystem(); </font></span> <font color="#010101"><span style="color: rgb(50, 135, 18);">// 인스턴스 estimator의 클래스 EstimationNode의 헤더파일에 클래스 MapView가 선언됨.</span></font> <span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">인스턴스 estimator의 구조체</span></span> <font color="#010101"><span style="color: rgb(50, 135, 18);">EstimationNode </span></font><span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">멤버에 클래스 MapView의 포인터(*)를 담을 그릇 mapView가 선언됨.</span></span></div><div><span style="color: rgb(50, 135, 18);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: '맑은 고딕';">(cf. mapView = new MapView(); new는 메모리 동적할당으로 포인터를 반환함. 따라서 결과적으로</span></span> <span style="color: rgb(50, 135, 18);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: '맑은 고딕';">MapView</span></span><span style="color: rgb(50, 135, 18);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: '맑은 고딕';">의 포인터 그릇 mapView 선언에 상응함) </span></span><span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">mapView 포인터가 가리키는 객체에 대해 startSystem() 함수 실행. </span></span></div><div align="left"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">                 -----------------------------------------------------</span></span></div><div align="left">                  <span style="color: rgb(0, 128, 0);"><b>MapView::startSystem()</b></span> <span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';"><b><span style="color: rgb(0, 128, 0);">함수</span></b></span> <span style="font-family: '맑은 고딕';">(</span><span style="font-family: '맑은 고딕';">from MapView.cpp) <span style="color: rgb(51, 102, 255);"><u><b>시스템 및 각각의 쓰레드 실행 (MapView.h)</b></u></span></span></span></div><div align="left" style="margin-left: 80px;"><span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';">void MapView::startSystem()</span></span></div><div align="left" style="margin-left: 80px;"><span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';">{</span></span></div><div align="left" style="margin-left: 80px;"><span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';">keepRunning = true; </span></span> <span style="color: rgb(50, 135, 18);">// </span><span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">void MapView::run() 실행시 반영됨 </span></span><span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">(</span><span style="font-family: '맑은 고딕';">from MapView.cpp)</span></span></div><div align="left" style="margin-left: 80px;"><span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';">changeSizeNextRender = false;</span></span></div><div align="left" style="margin-left: 80px;"><span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';">start();</span></span></div><div align="left" style="margin-left: 80px;"><span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';">}</span></span></div><div align="left" style="margin-left: 80px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div><div><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101">  estimator.Loop();</font></span></div><div align="left" style="font-family:gotham, helvetica, arial, sans-serif;font-size:14px;margin-left:80px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;"><b>EstimationNode::Loop()</b> 함수 (from EstimationNode.cpp)</span></span></div><div align="left" style="margin-left:80px;">void EstimationNode::Loop()</div><div align="left" style="margin-left:40px;">         {</div><div align="left" style="margin-left:80px;">ros::Rate pub_rate(publishFreq); <span style="color: rgb(0, 128, 0);">// 생성자. publishFreq(Hz)(EstimationNode 생성자 실행시 저장)를 pub_rate에 저장. <a href="http://docs.ros.org/indigo/api/rostime/html/classros_1_1Rate.html"><span style="color: rgb(0, 128, 0);">참고링크</span></a></span></div><div><span style="color: rgb(0, 128, 0);">                   </span> ros::Time lastInfoSent = ros::Time::now(); <span style="color: rgb(0, 128, 0);">// 현재시각을 lastInfoSent에 저장</span></div><div align="left" style="margin-left:80px;">while (nh_.ok()) <span style="color: rgb(0, 128, 0);">// 종료여부 판단. (ok()가 true이면서) shutdown()이 아직 호출되지 않았으면 true 반환, 호출되었으면 false 반환.<a href="http://docs.ros.org/indigo/api/roscpp/html/classros_1_1NodeHandle.html#ab4ee3d7b4d7fe52696fcfb84cc388331"><span style="color: rgb(0, 128, 0);"> </span></a></span><span style="color: rgb(0, 128, 0);"><a href="http://docs.ros.org/indigo/api/roscpp/html/classros_1_1NodeHandle.html#ab4ee3d7b4d7fe52696fcfb84cc388331" rev="en_rl_small"><span style="color: rgb(0, 128, 0);">참고링크</span></a> </span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);">                         cf. shutdown() :  RosThread.cpp에서 호출. 이 노드를 통해 발행하는 모든 토픽과 서비스의 발행 중단 및 구독 중단 기능. <a href="http://docs.ros.org/indigo/api/roscpp/html/classros_1_1NodeHandle.html#a81d08224944993c4cd38589e68417e12" rev="en_rl_minimal"><span style="color: rgb(0, 128, 0);">참고링크</span></a></span></div><div align="left" style="margin-left:80px;">{</div><div align="left" style="margin-left:80px;">/////// 1. nav와 control을 내부 큐queue에 넣음</div><div align="left" style="margin-left:80px;">ros::spinOnce(); <span style="color: rgb(0, 128, 0);">// 메시지를 받으면 ROS는 해당 콜백함수를 (즉각 처리하지 않고) 큐에 넣음. spinOnce()가 호출되면 콜백함수 처리. 즉, spinOnce() 주기로 주기를 조절해 콜백을 처리하는 것.</span> <a href="http://wiki.ros.org/roscpp/Overview/Callbacks%20and%20Spinning">참고링크</a> </div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);">                             </span> <span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:40px;"><span style="color: rgb(0, 128, 0);"><b>                                        EstimationNode::navdataCb 함수</b></span><b><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);"> </span></span></b> <span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">(from EstimationNode.cpp)</span></span></div><div align="left" style="margin-left:280px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">void EstimationNode::navdataCb(const ardrone_autonomy::NavdataConstPtr navdataPtr) <span style="color: rgb(0, 128, 0);">// 매개변수로 navdata 포인터를 전달</span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">{</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">lastNavdataReceived = *navdataPtr; <span style="color: rgb(0, 128, 0);">// navdata 포인터가 가리키는 객체를 EstimationNode의 멤버 변수 lastNavedataReceived에 담음</span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">if(ros::Time::now() - lastNavdataReceived.header.stamp &gt; ros::Duration(30.0)) </span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">lastNavdataReceived.header.stamp = ros::Time::now(); <span style="color: rgb(0, 128, 0);">// </span></span><span style="color: rgb(0, 128, 0);">&quot;현재시간 -  lastNavdataReceived의 타임스탬프&quot; &gt; 30초라면(navdata의 마지막 타임스탬프가 30초 이전이라면) </span><span style="color: rgb(0, 128, 0);">현재시간을 </span> <span style="color: rgb(0, 128, 0);">lastNavdataReceived의 타임스탬프에 저장</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">if(arDroneVersion == 0) </span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">{</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">arDroneVersion = (navdataPtr-&gt;pressure == 0) ? 1 : 2; </span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">std::cout &lt;&lt;&quot;Found ARDrone Version &quot; &lt;&lt; arDroneVersion &lt;&lt; std::endl; </span><span style="color: rgb(0, 0, 0);"><span style="color: rgb(0, 128, 0);">// </span></span><span style="color: rgb(0, 128, 0);">EstimationNode의 멤버 변수 arDroneVersion 값이 0이면 </span><span style="color: rgb(0, 128, 0);">navdata의 기압값을 확인해서 0이면 1을, 0이 아니면 2를 arDroneVersion에 저장하고, 출력</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">}</span></div><div align="left" style="margin-left:240px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">(ROS는 타임스탬프를 잘 망침. 매 5ms마다</span> <span style="color: rgb(0, 0, 0);">(패키지와 함께)</span> <span style="color: rgb(0, 0, 0);">도착해야 하는데, 최대 30ms까지 갭이 생겨 (같은 타임스탬프가 찍힌 6개의 패키지와 함께) 도착함. 그래서 받은 패키지의 타임스탬프를 순서에 잘 맞게 최대 20ms까지 옮겨 부드럽게smoothes out 하는 것이 다음 작업임)</span><span style="color: rgb(0, 128, 0);">      cf. ms(밀리초) = 1/1000s     </span><span style="color: rgb(0, 128, 0);">us(마이크로초) = 1/1000,000s     </span><span style="color: rgb(0, 128, 0);">ns(나노초) = 1/1,000,000,000</span> <span style="color: rgb(255, 102, 0);">   cf. 아래에서 시간 단위들은 한번 더 확인 필요</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">long rosTS = getMS(lastNavdataReceived.header.stamp); <span style="color: rgb(0, 128, 0);">// </span></span> <span style="color: rgb(0, 128, 0);">현재 타임스탬프 - 타임스탬프 베이스(이전 타임스탬프(없을 때는 현재 타임스탬프)) 값(단위는 ms)을 rosTS에 저장. getMS 함수 정의는 HelperFunctions.h 참고. </span></div><div align="left" style="margin-left:280px;"><span style="color: rgb(0, 128, 0);"> cf. getMS()의 리턴값 mss = (stamp.sec - ros_header_timestamp_base) * 1000 + stamp.nsec/1000000;</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">long droneTS = navdataPtr-&gt;tm / 1000; <span style="color: rgb(0, 128, 0);">// navdata 포인터의 tm(단위는 um)/1000. (최종단위는 ms)을 droneTS에 저장. tm 정의는 ardrone_autonomy/Navdata.msg 참고.</span></span> <a href="http://docs.ros.org/indigo/api/ardrone_autonomy/html/msg/Navdata.html" rev="en_rl_minimal">참고링크</a></div><div align="left" style="margin-left:280px;">  <span style="color: rgb(255, 0, 0);">?? navdataPtr.tm과 navdata.header.stamp는 같은가 다른가??</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">if(lastDroneTS == 0) lastDroneTS = droneTS; <span style="color: rgb(0, 128, 0);">// lastDroneTS가 0이면 droneTS값을 lastDroneTS에 저장</span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">if((droneTS+1000000) &lt; lastDroneTS) <span style="color: rgb(255, 102, 0);">// droneTS에 1000000ms(1000초;17분)를 더한 값이 lastDroneTS보다 작으면 (의미?) 현재 드론시각에 17분 더한 시각이 </span></span> <span style="color: rgb(0, 0, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="color: rgb(255, 102, 0);">마지막 드론시각보다 작다면</span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">{</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">droneRosTSOffset = rosTS - droneTS; (<span style="color: rgb(255, 102, 0);">타임스탬프 오버플로우</span>. 이동 평균running average</span> <span style="color: rgb(0, 0, 0);">재설정)</span></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 128, 0);">cf. 이동 평균 : 2개 이상의 연속된 입력 값의 평균을 계속 계산</span></div></div><div align="left" style="margin-left:280px;"><span style="color: rgb(255, 102, 0);">타임스탬프 에러. ros시각과 드론시각 차이를 '드론ros시각차(오프셋)'로 재설정. </span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">ROS_WARN(&quot;Drone Navdata timestamp overflow! (should happen epprox every 30min, while drone switched on)&quot;); <span style="color: rgb(0, 128, 0);">// 드론이 켜져 있으면 약 30분마다 타임스탬프 오버플로우가 발생</span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">}</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">else</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">droneRosTSOffset = 0.9 * droneRosTSOffset + 0.1*(rosTS - droneTS); <span style="color: rgb(255, 102, 0);"><span style="color: rgb(0, 128, 0);">// 그렇지않다면(드론시각+1000초가 마지막 드론시각보다 크면), '드론ros시각차' * 0.9 + (rosTS-droneTS)* 0.1로 '드론ros시각차'를 보정.</span> (의미?)</span></span></div><div align="left" style="margin-left:280px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">long rosTSNew =droneTS + droneRosTSOffset;</span> <span style="color: rgb(0, 128, 0);"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">//</span> 드론시각+드론ros시각차,를 새 ros시각으로 저장. 이것이 정확한 timestamp가 되어야 함</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">long TSDiff = std::min(100l,std::max(-100l,rosTSNew-rosTS)); /<span style="color: rgb(0, 128, 0);">/ 새 ros시각과 -1001 중 큰 것, 그것과 1001 중 작은 것을 TSDiff로 저장</span><span style="color: rgb(255, 102, 0);">-&gt; TSDiff는 -1001 ~ 1000 사이 값이 됨.</span> <span style="color: rgb(0, 128, 0);">(100ms 이상 바꾸지 말아야.)</span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">lastNavdataReceived.header.stamp += ros::Duration(TSDiff/1000.0);  <span style="color: rgb(0, 128, 0);">// lastNavdataReceived의 헤더스탬프에  TSDiff를 1000으로 나눈 값을 더</span><span style="color: rgb(255, 102, 0);"><span style="color: rgb(0, 128, 0);">함.</span> (헤더 스탬프 변경!)</span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">lastRosTS = rosTS;</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">lastDroneTS = droneTS;</span></div><div align="left" style="margin-left:280px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">(원래 보낸originally sent 드론 값으로 변환(ardrone_autonomy의 변화를 되돌림))</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">lastNavdataReceived.rotZ *= -1; (변환된 yaw) <span style="color: rgb(0, 128, 0);">// 마지막 받은 Navdata의 rotZ(Z축 회전rotation)값을 음수 부호 붙여 저장</span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">lastNavdataReceived.rotY *= -1; (변환된 pitch)</span> <span style="color: rgb(0, 128, 0);">// '' (Y축 회전rotation)값 다시 저장</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">lastNavdataReceived.vy *= -1;</span> <span style="color: rgb(0, 0, 0);">(변환된</span> <span style="color: rgb(0, 0, 0);">ya</span>w<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 128, 0);">// '' vy(y축 선속도linear velocity)값 다시 저장</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">lastNavdataReceived.vz *= -1;</span> <span style="color: rgb(0, 0, 0);">(변환된</span> <span style="color: rgb(0, 0, 0);">pitc</span>h<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 128, 0);">// '' vz(z축 선속도linear velocity)값 다시 저장</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">lastNavdataReceived.ay *= -1;</span> <span style="color: rgb(0, 0, 0);">(변환된</span> <span style="color: rgb(0, 0, 0);">ya</span>w<span style="color: rgb(0, 0, 0);">) </span><span style="color: rgb(0, 128, 0);">// '' ay(y축 선가속도linear accelerations)값 다시 저장</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">lastNavdataReceived.az *= -1;</span> <span style="color: rgb(0, 0, 0);">(변환된</span> <span style="color: rgb(0, 0, 0);">pitc</span>h<span style="color: rgb(0, 0, 0);">) </span><span style="color: rgb(0, 128, 0);">// '' az(z축 선가속도linear accelerations)값 다시 저장</span></div><div align="left" style="margin-left:240px;"><br/></div><div align="left" style="margin-left:200px;">(필터 큐에 넣기)</div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">pthread_mutex_lock( &amp;filter-&gt;filter_CS ); </span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 0, 0);">          filter-&gt;navdataQueue-&gt;push_back(lastNavdataReceived); </span> <span style="color: rgb(0, 0, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="color: rgb(0, 128, 0);">// 드론칼만필터 인스턴스 filter(주소값)의 navdataQueue에 객체 lastNavdataReceived(꾸러미)를 집어넣음</span></span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 0, 0);">          pthread_mutex_unlock( &amp;filter-&gt;filter_CS );</span></div><div align="left" style="margin-left:280px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">(PTAM에 전달(스케일 예측 위함))</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">ptamWrapper-&gt;newNavdata(&amp;lastNavdataReceived);</span> <span style="color: rgb(0, 0, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="color: rgb(0, 128, 0);">// PTAMWrapper 인스턴스 ptamWrapper(주소값)의 newNavdata에 &amp;lastNavdataReceived를 저장</span></span></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">                         </span> <span style="font-family: '맑은 고딕';font-size:14px;"><span style="color: rgb(50, 135, 18);"> -----------------------------------------------------</span></span> <span style="color: rgb(0, 0, 0);"> </span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">void PTAMWrapper::newNavdata(ardrone_autonomy::Navdata* nav) <span style="color: rgb(0, 128, 0);">// Navdata는 주소, Navdata*는 객체</span></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">{</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">lastNavinfoReceived = *nav; <span style="color: rgb(0, 128, 0);">// nav(&amp;lastNavdataReceived)가 가리키는 객체를 lastNavinfoReceived(객체)에 저장</span></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">if(getMS(lastNavinfoReceived.header.stamp) &gt; 2000000) <span style="color: rgb(0, 128, 0);">// </span></span> <span style="color: rgb(0, 128, 0);"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">lastNavinfoReceived.header.stamp를 ms(밀리초)로 바꾼 값이 2,000,000보다 크면(= lastNavinfoReceived.header.stamp가 2000s(33분)보다 크면)</span></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">{</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">printf(&quot;PTAMSystem: ignoring navdata package with timestamp %f\n&quot;, lastNavinfoReceived.tm); <span style="color: rgb(0, 128, 0);">// &quot;</span></span> <span style="color: rgb(0, 128, 0);"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">PTAMSystem: 타임스탬프</span> (<span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">lastNavinfoReceived.tm값)인 navdata 패키지 무시&quot; 출력</span></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">return;</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">}</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">if(lastNavinfoReceived.header.seq &gt; 2000000 || lastNavinfoReceived.header.seq &lt; 0) <span style="color: rgb(0, 128, 0);">// </span></span> <span style="color: rgb(0, 128, 0);"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">lastNavinfoReceived.header.seq가 2,000,000보다 크거나, 0보다 작으면(cf. seq : sequence ID. consecutively increasing ID)</span></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">{</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">printf(&quot;PTAMSystem: ignoring navdata package with ID %i\n&quot;, lastNavinfoReceived.header.seq); <span style="color: rgb(0, 128, 0);">// </span></span> <span style="color: rgb(0, 128, 0);"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">&quot;</span> <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">PTAMSystem:  ID</span> <span style="font-family:&quot;Helvetica Neue&quot;, Arial, sans;font-size:16px;">(</span><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">lastNavinfoReceived.header.seq값)인 패키지 무시&quot; 출력</span></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">return;</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">}</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);"><span style="color: rgb(0, 128, 0);">// 드론칼만필터 인스턴스 filter의 yaw로 yaw 수정</span></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">lastNavinfoReceived.rotZ = filter-&gt;getCurrentPose()[5]; <span style="color: rgb(0, 128, 0);">// filter의 getCurrentPose()[5](yaw.state[0])을 </span></span> <span style="color: rgb(0, 128, 0);"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">lastNavinfoReceived의 rotZ값으로 저장</span></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:440px;"><span style="font-family: '맑은 고딕';font-size:14px;"><span style="color: rgb(50, 135, 18);"> -----------------------------------------------------</span></span></div><div align="left" style="margin-left:440px;"><span style="color: rgb(0, 0, 0);">(from DroneKalmanFilter.cpp)</span></div><div align="left" style="margin-left:440px;"><span style="color: rgb(0, 0, 0);">TooN::Vector&lt;6&gt; DroneKalmanFilter::getCurrentPose()</span></div><div align="left" style="margin-left:440px;"><span style="color: rgb(0, 0, 0);">{</span></div><div align="left" style="margin-left:440px;"><span style="color: rgb(0, 0, 0);">return TooN::makeVector(x.state[0], y.state[0], z.state[0], roll.state, pitch.state, yaw.state[0]); <span style="color: rgb(0, 128, 0);">// </span></span> <span style="color: rgb(0, 128, 0);"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">x.state[0], y.state[0], z.state[0], roll.state, pitch.state, yaw.state[0]로 이루어진 벡터 반환</span></span></div><div align="left" style="margin-left:440px;"><span style="color: rgb(0, 0, 0);">}   </span></div><div align="left" style="margin-left:440px;"><span style="font-family: '맑은 고딕';font-size:14px;"><span style="color: rgb(50, 135, 18);"> -----------------------------------------------------</span></span> <span style="color: rgb(0, 0, 0);">       </span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">pthread_mutex_lock( &amp;navInfoQueueCS ); <span style="color: rgb(0, 128, 0);">// 뮤텍스 </span></span> <span style="color: rgb(0, 128, 0);"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">navInfoQueueCS 잠금</span></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">navInfoQueue.push_back(lastNavinfoReceived); <span style="color: rgb(0, 128, 0);">// </span></span> <span style="color: rgb(0, 128, 0);"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">navInfoQueue에 lastNavinfoReceived 넣기</span></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">if(navInfoQueue.size() &gt; 1000) // respective 5s <span style="color: rgb(0, 128, 0);">// </span></span> <span style="color: rgb(0, 128, 0);"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">navInfoQueue의 size()가 1000보다 크면 ??의미??</span></span></div></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">{</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">navInfoQueue.pop_front(); <span style="color: rgb(0, 128, 0);">// deque의 첫번째 요소 제거</span> </span><a href="http://www.cplusplus.com/reference/deque/deque/pop_front/" rev="en_rl_minimal">참고1</a> <a href="https://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a00918.html">참고</a>2</div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">if(!navQueueOverflown) <span style="color: rgb(0, 128, 0);">// navQueueOverflown가 False라면</span></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">printf(&quot;NavQue Overflow detected!\n&quot;); <span style="color: rgb(0, 128, 0);">// 메시지 출력</span></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">navQueueOverflown = true; <span style="color: rgb(0, 128, 0);">// navQueueOverflown을 True로 저장</span></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">}</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">pthread_mutex_unlock( &amp;navInfoQueueCS ); </span> <span style="color: rgb(0, 0, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="color: rgb(0, 128, 0);">// 뮤텍스 </span></span> <span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">navInfoQueueCS 잠금 해제</span></span></div><div align="left" style="margin-left:320px;"><br/></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">//filter-&gt;setPing(nav-&gt;pingNav, nav-&gt;pingVid);</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">imuOnlyPred-&gt;yaw = filter-&gt;getCurrentPose()[5];</span></div><div align="left" style="margin-left:320px;"><span style="font-family: '맑은 고딕';font-size:14px;"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(50, 135, 18);">                           (from Predictor.cpp)</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(50, 135, 18);">                            Predictor::Predictor(std::string basePath)</span></div><div align="left" style="margin-left:440px;"><span style="color: rgb(50, 135, 18);"> {</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">                   setPosRPY(0,0,0,0,0,0);</span></div><div align="left" style="margin-left:560px;"><span style="font-family: '맑은 고딕';font-size:14px;"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:560px;"><span style="color: rgb(50, 135, 18);">void Predictor::setPosRPY(double newX, double newY, double newZ, double newRoll, double newPitch, double newYaw)</span></div><div align="left" style="margin-left:560px;"><span style="color: rgb(50, 135, 18);">{</span></div><div align="left" style="margin-left:560px;"><span style="color: rgb(50, 135, 18);">// rpy 설정</span></div><div align="left" style="margin-left:560px;"><span style="color: rgb(50, 135, 18);">x = newX; y = newY; z = newZ;</span></div><div align="left" style="margin-left:560px;"><span style="color: rgb(50, 135, 18);">roll = newRoll; pitch = newPitch; yaw = newYaw;</span></div><div align="left" style="margin-left:560px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left" style="margin-left:560px;"><span style="color: rgb(50, 135, 18);">// set se3</span></div><div align="left" style="margin-left:560px;"><span style="color: rgb(50, 135, 18);">droneToGlobal.get_translation()[0] = x;</span></div><div align="left" style="margin-left:560px;"><span style="color: rgb(50, 135, 18);">droneToGlobal.get_translation()[1] = y;</span></div><div align="left" style="margin-left:560px;"><span style="color: rgb(50, 135, 18);">droneToGlobal.get_translation()[2] = z;</span></div><div align="left" style="margin-left:560px;"><span style="color: rgb(50, 135, 18);">droneToGlobal.get_rotation() = rpy2rod(roll,pitch,yaw);</span></div><div align="left" style="margin-left:560px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left" style="margin-left:560px;"><span style="color: rgb(50, 135, 18);">globaltoDrone = droneToGlobal.inverse();</span></div><div align="left" style="margin-left:560px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left" style="margin-left:560px;"><span style="color: rgb(50, 135, 18);">// set rest</span></div><div align="left" style="margin-left:560px;"><span style="color: rgb(50, 135, 18);">calcCombinedTransformations();</span></div><div align="left" style="margin-left:560px;"><span style="color: rgb(50, 135, 18);">}</span></div><div align="left" style="margin-left:560px;"><span style="font-family: '맑은 고딕';font-size:14px;"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:440px;"><span style="color: rgb(50, 135, 18);">lastAddedDronetime = 0;</span></div><div align="left" style="margin-left:440px;"><span style="color: rgb(50, 135, 18);">}</span></div><div align="left" style="margin-left:280px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:320px;"><span style="font-family: '맑은 고딕';font-size:14px;"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:240px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">imuOnlyPred-&gt;predictOneStep(&amp;lastNavinfoReceived);</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">}</span></div><div align="left" style="margin-left:320px;"><span style="font-family: '맑은 고딕';font-size:14px;"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div></div><div align="left" style="margin-left:280px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">(save last timestamp 저장)</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">if(lastNavStamp != ros::Time(0) &amp;&amp; (lastNavdataReceived.header.stamp - lastNavStamp &gt; ros::Duration(0.1))) </span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">std::cout &lt;&lt; (lastNavdataReceived.header.stamp - lastNavStamp).toSec() &lt;&lt; &quot;s between two consecutive navinfos. This system requires Navinfo at 200Hz. If this error persists, set drone to debug mode and change publish freq in ardrone_autonomy&quot; &lt;&lt; std::endl; <span style="color: rgb(0, 128, 0);">// </span></span><span style="color: rgb(0, 0, 0);"><span style="color: rgb(0, 128, 0);">lastNavStamp가 0이 아니면서 (lastNavdataReceived의 헤더 스탬프 - lastNavStamp)가 0.1초보다 크면, 다음 메시지 출력.</span></span> <span style="color: rgb(0, 0, 0);"><span style="color: rgb(0, 128, 0);">&quot;(lastNavdataReceived의 헤더스탬프 - lastNavStamp)초가 연속된 두 navinfo간의 값. 이 시스템은 200Hz의 Navinfo를 요청. 이 에러가 지속되면 드론을 디버그 모드로 설정하고, ardrone_autonomy의 발행주기를 바꿔라&quot;</span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">lastNavStamp = lastNavdataReceived.header.stamp; <span style="color: rgb(0, 128, 0);">// lastNavdataReceived의 헤더 스탬프를 lastNavStamp에 저장.</span></span></div><div align="left" style="margin-left:280px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">if(logfileIMU != NULL) <span style="color: rgb(0, 128, 0);">// IMU 로그파일이 NULL이 아니면,</span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">{</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">int pingNav = 0, pingVid = 0; <span style="color: rgb(0, 128, 0);">// pingNav와 pingVid를 0으로 설정, </span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">pthread_mutex_lock(&amp;logIMU_CS); /<span style="color: rgb(0, 128, 0);">/ 뮤텍스 logIMU_CS 잠금</span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">if(logfileIMU != NULL) <span style="color: rgb(0, 128, 0);">//</span></span> <span style="color: rgb(0, 128, 0);"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">IMU 로그파일이 NULL이 아니면,</span>  </span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">(*logfileIMU) &lt;&lt; getMS(lastNavdataReceived.header.stamp) &lt;&lt; &quot; &quot; &lt;&lt; lastNavdataReceived.tm &lt;&lt; &quot; &quot; &lt;&lt; </span><span style="color: rgb(0, 0, 0);">lastNavdataReceived.vx &lt;&lt; &quot; &quot; &lt;&lt; lastNavdataReceived.vy &lt;&lt; &quot; &quot; &lt;&lt; lastNavdataReceived.altd &lt;&lt; &quot; &quot; &lt;&lt; lastNavdataReceived.rotX/1000.0 &lt;&lt; &quot; &quot; &lt;&lt; lastNavdataReceived.rotY/1000.0 &lt;&lt; &quot; &quot; &lt;&lt; lastNavdataReceived.rotZ/1000.0 &lt;&lt; &quot; &quot; &lt;&lt; </span><span style="color: rgb(0, 0, 0);">lastNavdataReceived.pressure &lt;&lt; &quot; &quot; &lt;&lt;  0 &lt;&lt; &quot; &quot; &lt;&lt;  0 &lt;&lt; &quot; &quot; &lt;&lt; 0 &lt;&lt; &quot; &quot; &lt;&lt;  <span style="color: rgb(50, 135, 18);">  // control: roll pitch gaz yaw. </span></span><span style="color: rgb(0, 0, 0);">pingNav &lt;&lt; &quot; &quot; &lt;&lt; pingVid &lt;&lt; &quot;\n&quot;; <span style="color: rgb(0, 128, 0);">// </span></span> <span style="color: rgb(0, 128, 0);"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">IMU 로그파일에 다음을 씀: lastNavdataReceived의 {header.stamp, </span><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">tm,</span> <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">vx(x축선속도), vy(y축선속도), </span> <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">altd(고도예측cm), </span> <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">rotX/1000(x축각도milli degrees),</span> <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">rotY/1000(y축각도), rotZ/1000(z축각도),</span> <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">기압}, 0, 0, 0, pingNav, pingVid.</span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">pthread_mutex_unlock(&amp;logIMU_CS); </span> <span style="color: rgb(0, 128, 0);">// <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">뮤텍스 logIMU_CS 잠금 해제</span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 0, 0);">}}</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';font-size:14px;">                        --------------------------------------------</span></span></div><div align="left" style="margin-left:200px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 128, 0);"><b>EstimationNode::velCb 함수</b></span><b><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);"> </span></span></b> <span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">(from EstimationNode.cpp)</span></span></div><div align="left" style="margin-left:280px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:200px;">void EstimationNode::velCb(const geometry_msgs::TwistConstPtr velPtr)</div><div align="left" style="margin-left:200px;">{</div><div align="left" style="margin-left:200px;">geometry_msgs::TwistStamped ts; <span style="color: rgb(0, 128, 0);">// 인스턴스 ts 선언</span></div><div align="left" style="margin-left:200px;">ts.header.stamp = ros::Time::now(); <span style="color: rgb(0, 128, 0);">// 현재시간을 ts의 stamp에 저장</span></div><div align="left" style="margin-left:200px;">ts.twist = *velPtr; <span style="color: rgb(0, 128, 0);">// velPtr 포인터가 가리키는 값(선속도x,y,z,각속도x,y,z)을 ts의 twist에 저장</span></div><div align="left" style="margin-left:240px;"><br/></div><div align="left" style="margin-left:200px;">(여러 이유에서 다음 값들을 바꿈. linear.y가 ROLL에 상응)</div><div align="left" style="margin-left:200px;">ts.twist.linear.y *= -1; <span style="color: rgb(0, 128, 0);">// y선속도값을 -부호 붙여 저장</span></div><div align="left" style="margin-left:200px;">ts.twist.linear.x *= -1; <span style="color: rgb(0, 128, 0);">// x선속도값을 -부호 붙여 저장</span></div><div align="left" style="margin-left:200px;">ts.twist.angular.z *= -1; <span style="color: rgb(0, 128, 0);">// z각속도값을 -부호 붙여 저장</span></div><div align="left" style="margin-left:280px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:200px;">pthread_mutex_lock( &amp;filter-&gt;filter_CS ); </div><div align="left" style="margin-left:200px;">filter-&gt;velQueue-&gt;push_back(ts); <span style="color: rgb(50, 135, 18);">// 드론칼만필터 인스턴스 filter의 velQueue에 ts를 집어넣음</span></div><div align="left" style="margin-left:200px;">pthread_mutex_unlock( &amp;filter-&gt;filter_CS );</div><div align="left" style="margin-left:200px;">}</div><div align="left" style="margin-left:200px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:200px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 128, 0);"><b>EstimationNode::vidCb 함수</b></span><b><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);"> </span></span></b> <span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">(from EstimationNode.cpp)</span></span></div><div align="left" style="margin-left:280px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left" style="margin-left:200px;">void EstimationNode::vidCb(const sensor_msgs::ImageConstPtr img)</div><div align="left" style="margin-left:200px;">{</div><div align="left" style="margin-left:200px;">(PTAM에 전달)</div><div align="left" style="margin-left:200px;">ptamWrapper-&gt;newImage(img); <span style="color: rgb(50, 135, 18);">// PTAMWrapper 인스턴스 ptamWrapper의 newImage에 (전달받은 이미지포인터) img 저장</span></div><div align="left" style="margin-left:200px;">}</div><div align="left" style="margin-left:200px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:200px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 128, 0);"><b>EstimationNode::comCb 함수</b></span><b><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);"> </span></span></b> <span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">(from EstimationNode.cpp)</span></span></div><div align="left" style="margin-left:200px;">void EstimationNode::comCb(const std_msgs::StringConstPtr str)</div><div align="left" style="margin-left:200px;">{</div><div align="left" style="margin-left:200px;">if(str-&gt;data.length() &gt; 2 &amp;&amp; str-&gt;data.substr(0,2) == &quot;p &quot;)</div><div align="left" style="margin-left:200px;">{ ptamWrapper-&gt;handleCommand(str-&gt;data.substr(2,str-&gt;data.length()-2)); } <span style="color: rgb(50, 135, 18);">// (인자로 넘겨받은 포인터) str의 data 길이가 2보다 크고, &quot;p &quot;로 시작하면, ptamWrapper의 handleCommand에 &quot;p &quot; 다음 내용을 저장. handleCommand 반환형은 bool.<span style="color: rgb(250, 122, 0);">(의미?)</span></span></div><div align="left" style="margin-left:200px;">if(str-&gt;data.length() &gt; 2 &amp;&amp; str-&gt;data.substr(0,2) == &quot;f &quot;)</div><div align="left" style="margin-left:200px;">{ mapView-&gt;handleCommand(str-&gt;data.substr(2,str-&gt;data.length()-2)); } <span style="color: rgb(50, 135, 18);">// str의 data 길이가 2보다 크고, &quot;f &quot;로 시작하면, mapView의 handleCommand에 &quot;f &quot; 다음 내용을 저장</span></div><div align="left" style="margin-left:200px;">if(str-&gt;data.length() &gt; 2 &amp;&amp; str-&gt;data.substr(0,2) == &quot;m &quot;)</div><div align="left" style="margin-left:200px;">{ mapView-&gt;handleCommand(str-&gt;data.substr(2,str-&gt;data.length()-2)); } <span style="color: rgb(50, 135, 18);">// str의 data 길이가 2보다 크고, &quot;m &quot;로 시작하면, </span><span style="color: rgb(50, 135, 18);">mapView</span> <span style="color: rgb(50, 135, 18);">의 handleCommand에 &quot;m &quot; 다음 내용을 저장</span></div><div align="left" style="margin-left:200px;">if(str-&gt;data.length() == 9 &amp;&amp; str-&gt;data.substr(0,9) == &quot;toggleLog&quot;)</div><div align="left" style="margin-left:200px;">{ this-&gt;toogleLogging(); } <span style="color: rgb(50, 135, 18);">// (인자로 넘겨받은 포인터) str의 data 길이가 9이고, &quot;toogleLog&quot;이면, this의 toogleLogging();을 실행</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left" style="margin-left:200px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">                               ----------------------------------------------------</span></span></div><div align="left" style="margin-left:360px;">toogleLogging() 함수 <span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">(from EstimationNode.cpp)</span></span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">void EstimationNode::toogleLogging()  </span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">{</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    // first: always check for /log dir</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    struct stat st;</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    if(stat((packagePath+std::string(&quot;/logs&quot;)).c_str(),&amp;st) != 0)</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        mkdir((packagePath+std::string(&quot;/logs&quot;)).c_str(),S_IXGRP | S_IXOTH | S_IXUSR | S_IRWXU | S_IRWXG | S_IROTH);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    char buf[200];</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    bool quitLogging = false;</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    if(logfileIMU == 0)</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    {</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        currentLogID = ((long)time(0))*100+(getMS()%100);        // time(0) + ms</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        startedLogClock = getMS();</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        ROS_INFO(&quot;\n\nENABLED LOGGING to %s/logs/%ld\n\n\n&quot;,packagePath.c_str(),currentLogID);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        sprintf(buf,&quot;%s/logs/%ld&quot;,packagePath.c_str(),currentLogID);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        mkdir(buf, S_IXGRP | S_IXOTH | S_IXUSR | S_IRWXU | S_IRWXG | S_IROTH);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        sprintf(buf,&quot;u l ENABLED LOGGING to %s/logs/%ld&quot;,packagePath.c_str(),currentLogID);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        publishCommand(buf);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    }</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    else</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        quitLogging = true;</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    // IMU</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    pthread_mutex_lock(&amp;logIMU_CS);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    if(logfileIMU == 0)</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    {</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfileIMU = new std::ofstream();</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        sprintf(buf,&quot;%s/logs/%ld/logIMU.txt&quot;,packagePath.c_str(),currentLogID);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfileIMU-&gt;open (buf);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    }</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    else</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    {</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfileIMU-&gt;flush();</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfileIMU-&gt;close();</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        delete logfileIMU;</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfileIMU = NULL;</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    }</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    pthread_mutex_unlock(&amp;logIMU_CS);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    // IMU</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    pthread_mutex_lock(&amp;logPTAM_CS);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    if(logfilePTAM == 0)</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    {</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfilePTAM = new std::ofstream();</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        sprintf(buf,&quot;%s/logs/%ld/logPTAM.txt&quot;,packagePath.c_str(),currentLogID);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfilePTAM-&gt;open (buf);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    }</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    else</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    {</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfilePTAM-&gt;flush();</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfilePTAM-&gt;close();</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        delete logfilePTAM;</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfilePTAM = NULL;</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    }</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    pthread_mutex_unlock(&amp;logPTAM_CS);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    // IMU</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    pthread_mutex_lock(&amp;logFilter_CS);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    if(logfileFilter == 0)</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    {</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfileFilter = new std::ofstream();</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        sprintf(buf,&quot;%s/logs/%ld/logFilter.txt&quot;,packagePath.c_str(),currentLogID);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfileFilter-&gt;open (buf);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    }</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    else</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    {</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfileFilter-&gt;flush();</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfileFilter-&gt;close();</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        delete logfileFilter;</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfileFilter = NULL;</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    }</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    pthread_mutex_unlock(&amp;logFilter_CS);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    // IMU</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    pthread_mutex_lock(&amp;logPTAMRaw_CS);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    if(logfilePTAMRaw == 0)</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    {</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfilePTAMRaw = new std::ofstream();</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        sprintf(buf,&quot;%s/logs/%ld/logPTAMRaw.txt&quot;,packagePath.c_str(),currentLogID);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfilePTAMRaw-&gt;open (buf);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    }</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    else</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    {</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfilePTAMRaw-&gt;flush();</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfilePTAMRaw-&gt;close();</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        delete logfilePTAMRaw;</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        logfilePTAMRaw = NULL;</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    }</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    pthread_mutex_unlock(&amp;logPTAMRaw_CS);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);"><br/></span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    if(quitLogging)</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    {</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        printf(&quot;\n\nDISABLED LOGGING (logged %ld sec)\n\n\n&quot;,(getMS()-startedLogClock+500)/1000);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        char buf2[200];</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        sprintf(buf,&quot;%s/logs/%ld&quot;,packagePath.c_str(),currentLogID);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        sprintf(buf2,&quot;%s/logs/%ld-%lds&quot;,packagePath.c_str(),currentLogID,(getMS()-startedLogClock+500)/1000);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">        rename(buf,buf2);</span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(50, 135, 18);">    }</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(50, 135, 18);">          }</span></div><div align="left" style="margin-left:200px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">                               ----------------------------------------------------</span></span></div><div align="left" style="margin-left:360px;"><br/></div><div align="left" style="margin-left:200px;">int a, b;</div><div align="left" style="margin-left:200px;">if(sscanf(str-&gt;data.c_str(),&quot;pings %d %d&quot;,&amp;a, &amp;b) == 2)</div><div align="left" style="margin-left:200px;">{ filter-&gt;setPing((unsigned int)a, (unsigned int)b);  <span style="color: rgb(50, 135, 18);">// str의 data 문자열 &quot;pings %d %d&quot;를 읽어온 %d,%d값을 &amp;a, &amp;b에 저장. 읽어온 갯수가 2개면 드론칼만필터 인스턴스 filter의 setPing에 a, b 저장.</span></div><div align="left" style="margin-left:200px;">predTime = ros::Duration((0.001*filter-&gt;delayControl)); <span style="color: rgb(50, 135, 18);">// (predTime을 새 delayControl로 설정)  // filter의 delayControl 값 *0.001 한 시간을 predTime으로 저장. (</span><span style="color: rgb(250, 122, 0);"><span style="color: rgb(0, 128, 0);">predTime은 ros::Duration 타입임. ros::Duration은 s, ns두 개 멤버를 갖는데, 0.001* x이므로 s=0, ns=x * 1,000,000 값을 가짐)</span></span></div><div align="left" style="margin-left:200px;">}}</div><div align="left" style="margin-left:200px;"><span style="font-family: '맑은 고딕';font-size:14px;"><span style="color: rgb(50, 135, 18);">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:120px;">/////// 3. 예측위치(포즈)predicted pose를 얻어서 발행!</div><div align="left" style="margin-left:120px;">( filter_state msg 얻어오기) <a href="http://docs.ros.org/indigo/api/tum_ardrone/html/msg/filter_state.html" rev="en_rl_minimal">참고링크</a></div><div align="left" style="margin-left:120px;">pthread_mutex_lock( &amp;filter-&gt;filter_CS ); <span style="color: rgb(0, 128, 0);">// filter의 filter_CS 뮤텍스 잠금</span></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 128, 0);">       (cf.  filter = new DroneKalmanFilter(this); (from EstimationNode.cpp)</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 128, 0);">       DroneKalmanFilter* filter;</span> <span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;">(from EstimationNode.h)</span> <span style="color: rgb(0, 128, 0);">  // 클래스</span> <span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;">DroneKalmanFilter* 의 인스턴스 filter.</span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 128, 0);">       static pthread_mutex_t filter_CS; (from DroneKalmanFilter.h) // </span> <span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;">클래스</span><span style="font-family:&quot;Helvetica Neue&quot;, Arial, sans;font-size:16px;"> </span><span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;">DroneKalmanFilter의 뮤텍스 filter_CS 선언)</span></div></div><div align="left" style="margin-left:240px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:120px;">tum_ardrone::filter_state s = filter-&gt;getPoseAt(ros::Time().now() + predTime); <span style="color: rgb(0, 128, 0);">// filter에 대해 getPoseAt() 함수 실행</span></div><div align="left" style="margin-left:80px;"><div style="margin-left:80px;"><span style="color: rgb(0, 128, 0);">                       </span> <span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';font-size:14px;">   -----------------------------------------------------</span></span></div><div style="margin-left:40px;"><span style="color: rgb(0, 128, 0);">                                    <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;"><b>DroneKalmanFilter::getPoseAt()</b> 함수 (from DroneKalmanFilter.cpp)</span></span></div><div align="left" style="margin-left:200px;">tum_ardrone::filter_state DroneKalmanFilter::getPoseAt(ros::Time t, bool useControlGains)</div></div><div align="left" style="margin-left:280px;">{</div><div align="left" style="margin-left:280px;">DroneKalmanFilter scopy = DroneKalmanFilter(*this); <span style="color: rgb(0, 128, 0);">//( 얕은 복사). DroneKalmanFilter를 복사해 scopy에 저장.</span></div><div align="left" style="margin-left:280px;">scopy.predictUpTo(getMS(t),false, useControlGains); <span style="color: rgb(0, 128, 0);">// (카피 scopy를 이용해 예측). predictUpTo() 실행.</span></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';font-size:14px;">                          -----------------------------------------------------</span></span></div><div align="left" style="margin-left:200px;"><span style="color: rgb(0, 128, 0);">                           <span style="color: rgb(0, 0, 0);"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;"><b>DroneKalmanFilter::predictUpTo()</b> 함수 </span> <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">(from DroneKalmanFilter.cpp)</span></span></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">void DroneKalmanFilter::predictUpTo(int timestamp, bool consume, bool useControlGains)  </span></div></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">{</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><span style="color: rgb(0, 0, 0);">if(predictdUpToTimestamp == timestamp) return;</span> // </span><span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;">predictdUpToTimestamp와 timestamp가 같으면 리턴</span> <span style="color: rgb(0, 128, 0);">      </span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(255, 102, 0);">//std::cout &lt;&lt; (consume ? &quot;per&quot; : &quot;tmp&quot;) &lt;&lt; &quot; pred @ &quot; &lt;&lt; this &lt;&lt; &quot;: &quot; &lt;&lt; predictdUpToTimestamp &lt;&lt; &quot; to &quot; &lt;&lt; timestamp &lt;&lt; std::endl;</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:320px;"><span style="color: rgb(255, 102, 0);">// at this point:</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(255, 102, 0);">// - velQueue contains controls, timestamped with time at which they were sent.</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(255, 102, 0);">// - navQueue contains navdata, timestamped with time at which they were received.</span></div></div><div align="left" style="margin-left:400px;"><span style="color: rgb(255, 102, 0);">// - timestamp is the time up to which we want to predict, i.e. maybe a little bit into the feature</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(255, 102, 0);">// 이 지점에서:</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(255, 102, 0);">velQueue는 보내졌을 때의 타임스탬프와 controls를 포함.</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(255, 102, 0);">navQueue는 수신되었을 때의 타임스탬프와 navdata를 포함.</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(255, 102, 0);">타임스탬프는 예측하고자 하는 시각. 예컨대 잠시 후의 미래. </span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(255, 102, 0);">[predictdUpToTimestamp]에서 시작. [currentTimestamp]에서, <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">[currentTimestamp-delayControl] 타임스탬프가 찍힌 control을 이용해, 차례로</span>[currentTimestamp+delayRPY] 타임스탬프가 찍힌 rpy,  <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">[currentTimestamp+delayXYZ] 타임스탬프가 찍힌 xyz 관측치 예측. </span></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(255, 102, 0);">사용될 첫번째 패키지까지 앞으로 감기fast forward. 컨트롤 반복자에 대해서는, 이것이 원래 그래야 하는 값보다 더 작거나 같은 마지막 패키지. 둘 다에 대해선, thi는 원래 그래야 하는 것보다 더 큰 첫번째 패키지.</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(255, 102, 0);">consume이 True면, 영구적이기 전에 모두 삭제.</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(255, 102, 0);">// start at [predictdUpToTimestamp]. predict step-by-step observing at [currentTimestamp] the</span></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:320px;"><span style="color: rgb(255, 102, 0);">// - rpy timestamped with [currentTimestamp + delayRPY]</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(255, 102, 0);">// - xyz timestamped with [currentTimestamp + delayXYZ]</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(255, 102, 0);">// using</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(255, 102, 0);">// - control timestamped with [currentTimestamp - delayControl]</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(255, 102, 0);"><br/></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(255, 102, 0);">// fast forward until first package that will be used.</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(255, 102, 0);">// for controlIterator, this is the last package with a stamp smaller/equal than what it should be.</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(255, 102, 0);">// for both others, thi is the first package with a stamp bigger than what it should be.</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(255, 102, 0);">// if consume, delete everything before permanently.</span></div></div><div align="left" style="margin-left:400px;"><br/></div><div align="left" style="margin-left:400px;"><span style="color: rgb(255, 102, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">std::deque&lt;geometry_msgs::TwistStamped&gt;::iterator controlIterator = velQueue-&gt;begin();  <span style="color: rgb(0, 128, 0);">// velQueue의 begin() 리턴값을 반복자 controlIterator에 저장.(cf. deque::begin : deque 컨테이너의 첫번째 요소를 가리키는 반복자iterator 반환 </span></span><a href="http://www.cplusplus.com/reference/deque/deque/begin/" rev="en_rl_minimal">참고</a>)</div><div align="left" style="margin-left:400px;"><br/></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">while(controlIterator != velQueue-&gt;end() &amp;&amp;</span></div></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">controlIterator+1 != velQueue-&gt;end() &amp;&amp;</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">getMS((controlIterator+1)-&gt;header.stamp) &lt;= predictdUpToTimestamp - delayControl) <span style="color: rgb(0, 128, 0);"> // velQueue의 end() 리턴값이 controlIterator가 아니고, </span></span> <span style="color: rgb(0, 128, 0);"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">controlIterator+1도 아니고, controlIterator+1의 헤더스탬프를 밀리초로 바꾼 시각이  predictdupToTimestamp - delayControl보다 작거나 같은 동안, (cf. deque::end : deque 컨테이너의 마지막 요소 바로 다음 지점을 가리키는 반복자 반환 </span></span><a href="http://www.cplusplus.com/reference/deque/deque/end/" rev="en_rl_minimal">참고</a> <a href="http://soen.kr/lecture/ccpp/cpp4/39-1-2.htm" rev="en_rl_minimal">참고</a>) <span style="color: rgb(255, 102, 0);">?? 무슨의미??</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">if(consume) </span></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">{</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">velQueue-&gt;pop_front();</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">controlIterator = velQueue-&gt;begin();</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">}</span></div></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">else</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">controlIterator++; <span style="color: rgb(0, 128, 0);">// consume이 True면 velQueue의 pop_front() 실행(deque 컨테이너의 첫번째 요소 삭제), velQueue의begin() 리턴값을 controlIterator에 저장(velQueue 첫째 요소 가리키는 반복자를 controlIterator에 저장), True가 아니면 controlIterator를 1 증가시킴</span></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">if(velQueue-&gt;size() == 0) useControlGains = false; <span style="color: rgb(0, 128, 0);">// velQueue의 size가 0이면 useControlGains를 false로 설정</span>                                     </span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);">// 여기서 삭제하지 말 것. (아래에서) rpy데이터가 consumed되면 삭제됨</span></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">std::deque&lt;ardrone_autonomy::Navdata&gt;::iterator xyzIterator = navdataQueue-&gt;begin();</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">while(xyzIterator != navdataQueue-&gt;end() &amp;&amp;</span></div></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">getMS(xyzIterator-&gt;header.stamp) &lt;= predictdUpToTimestamp + delayXYZ)</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">xyzIterator++; <span style="color: rgb(0, 128, 0);">// navdataQueue의 첫째요소를 가리키는 반복자를 xyzIterator에 저장. xyzIterator가 navdataQueue의 마지막요소를 가리키지 않고, xyzIterator의 헤더 스탬프를 밀리초로 바꾼 시각이 predictdUpToTimestamp + delayXYZ보다 작은 동안, xyzIterator를 1 증가시킴</span></span></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">std::deque&lt;ardrone_autonomy::Navdata&gt;::iterator rpyIterator = navdataQueue-&gt;begin();</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">while(rpyIterator != navdataQueue-&gt;end() &amp;&amp;</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">getMS(rpyIterator-&gt;header.stamp) &lt;= predictdUpToTimestamp + delayRPY)</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">if(consume)</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">{</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">navdataQueue-&gt;pop_front();</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">rpyIterator = navdataQueue-&gt;begin();</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">}</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">else</span></div></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">rpyIterator++;</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);">// navdataQueue의 첫째 요소를 가리키는 반복자를 rpyIterator에 저장. rpyIterator가 navdataQueue의 마지막 요소 다음지점을 가리키지 않고, rpy</span><span style="color: rgb(0, 0, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="color: rgb(0, 128, 0);">Iterator의 헤더 스탬프를 밀리초로 바꾼 시각이 predictdUpToTimestamp + delayRPY보다 작은 동안, consume이 True면, navdataQueue의 첫번째 요소 삭제. 다시 처음으로 오는 요소를 가리키는 반복자를 rpyIterator에 저장. True가 아니면 rpyIterator를 1 증가시킴</span></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);">(이제 모든 반복자가 통합될/적분될to be integrated 큐의 첫째 요소를 가리킴)</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);">(예측 시작)</span></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">while(true)</span></div></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">{</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><span style="color: rgb(0, 0, 0);">int predictTo = timestamp;</span> // (</span> <span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;">[timestamp]에 앞서 예측.)</span> <span style="color: rgb(0, 128, 0);">timestamp를 predictTo에 저장</span></div><div align="left" style="margin-left:400px;"><br/></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">predictTo = min(predictTo, predictdUpToTimestamp+10);</span> <span style="color: rgb(0, 128, 0);">//</span> <span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;">(비선형성을 보장하기 위해, 최대치를 10밀리초/예측단계(10ms per prediction step)로 함.</span><span style="color: rgb(0, 128, 0);">) predictTo와 predictUpToTimestamp+10 중 작은값을 predictTo에 저장</span></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 128, 0);"><br/></span></div></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);">(세 개 큐를 움직여 정확한 시점을 가리키게 함)</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);">(xyz는 관측시점obs-time이 </span> <span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;">[predictdUpToTimestamp]보다 크거나 같은 첫번째 지점point)</span></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">while(xyzIterator != navdataQueue-&gt;end() &amp;&amp;</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">getMS(xyzIterator-&gt;header.stamp) - delayXYZ &lt; predictdUpToTimestamp)</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">xyzIterator++;</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">while(rpyIterator != navdataQueue-&gt;end() &amp;&amp;</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">getMS(rpyIterator-&gt;header.stamp) - delayRPY &lt; predictdUpToTimestamp)</span></div></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">rpyIterator++;</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);">(스탬프가 <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">predictdUpToTimestamp에서 </span> <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">delayControl을 뺀 것보다 크지 않은 마지막 메시지 제어를 위해)</span></span></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">while(controlIterator != velQueue-&gt;end() &amp;&amp;</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">controlIterator+1 != velQueue-&gt;end() &amp;&amp;</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">getMS((controlIterator+1)-&gt;header.stamp) + delayControl &lt;= predictdUpToTimestamp)</span></div></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">controlIterator++;</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);">//  x<span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">yzIterator가 navdataQueue의 마지막 다음지점을 가리키는 반복자와 같지 않고, </span> <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">x</span><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">yzIterator의 헤더스탬프를 밀리초로 바꾼 시각에서 delayXYZ를 뺀 값이 </span> <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">predictdUpToTimestamp보다 작은 동안, </span> <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">x</span><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">yzIterator를 1 증가시킴.</span></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">rpyIterator가 </span> <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">navdataQueue의 마지막 다음지점을 가리키는 반복자와 같지 않고, rpyIterator의 헤더스탬프를 밀리초로 바꾼 시각에서 delayRPY를 뺀 값이 </span></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">predictdUpToTimestamp보다 작은 동안, </span> <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">rpyIterator를 1 증가시킴.</span></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);">controlIterator나 controlIterator+1이 velQueue의 <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">마지막 다음지점을 가리키는 반복자와 같지 않고, controlIterator+1의 헤더스탬프를 밀리초로 바꾼 시각에 delayControl을 더한 시각이 predictUpToTimestamp보다 크지 않은 동안, controlIterator를 1 증가시킴.</span></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);">( 다음 관측치가 더해져야 할 시점 이상을 예측하지 않도록 함)</span></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">if(rpyIterator != navdataQueue-&gt;end() )</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">predictTo = min(predictTo, getMS(rpyIterator-&gt;header.stamp)-delayRPY);</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">if(xyzIterator != navdataQueue-&gt;end() )</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">predictTo = min(predictTo, getMS(xyzIterator-&gt;header.stamp)-delayXYZ);</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);"><span style="color: rgb(255, 0, 255);"><b>predictInternal</b></span>(useControlGains ? controlIterator-&gt;twist : geometry_msgs::Twist(),</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">(predictTo - predictdUpToTimestamp)*1000,</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">useControlGains &amp;&amp;</span></div></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">getMS(controlIterator-&gt;header.stamp) + 200 &gt; predictdUpToTimestamp - delayControl); // control max. 200ms old.</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">// rpyIterator가</span><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">navdataQueue의 마지막 다음지점을 가리키는 반복자와 같지 않다면, predictTo와, rpyIterator의 헤더 스탬프를 밀리초로 바꾼 시각에서 delayRPY를 뺀 시각 중 작은 값을 predictTo에 저장.</span></span></div><div align="left" style="font-family:gotham, helvetica, arial, sans-serif;font-size:14px;margin-left:400px;"><span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">xyzIterator가</span><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">navdataQueue의 마지막 다음지점을 가리키는 반복자와 같지 않다면, predictTo와, xyzIterator의 헤더 스탬프를 밀리초로 바꾼 시각에서 delayXYZ를 뺀 시각 중 작은 값을 predictTo에 저장.</span></span></div><div align="left" style="font-family:gotham, helvetica, arial, sans-serif;font-size:14px;margin-left:400px;"><span style="color: rgb(0, 128, 0);">predictInternal(useControlGains가 참이면 controlIterator의 twist / 참이 아니면 geometry_msgs::Twist(), predictTo에서 predictdUpToTimestamp를 뺀 값 * 1000, useControlGains이 참이면서(&amp;&amp;), controlIterator의 헤더스탬프를 밀리초로 바꾼 값 +200이 predictdUpToTimestamp에서 delayControl을 뺀 값보다 큰지 여부(참/거짓)</span></div><div align="left" style="font-family:gotham, helvetica, arial, sans-serif;font-size:14px;margin-left:400px;"><span style="color: rgb(0, 128, 0);">(최대 200밀리초 전까지 제어)</span></div><div align="left" style="font-family:gotham, helvetica, arial, sans-serif;font-size:14px;margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="font-family:gotham, helvetica, arial, sans-serif;font-size:14px;margin-left:400px;"><span style="color: rgb(0, 128, 0);">//cout &lt;&lt; &quot; &quot; &lt;&lt; (predictTo - predictdUpToTimestamp);</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);">(cf. 내부에서 호출된 함수지만, 공간이 너무 좁아 밖으로 뺌)</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);">--------------------------------------------------------------</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">// this function does the actual work, predicting one timestep ahead.</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">void DroneKalmanFilter::predictInternal(geometry_msgs::Twist activeControlInfo, int timeSpanMicros, bool useControlGains)</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">{</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">if(timeSpanMicros &lt;= 0) return;</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">useControlGains = useControlGains &amp;&amp; this-&gt;useControl;</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">bool controlValid = !(activeControlInfo.linear.z &gt; 1.01 || activeControlInfo.linear.z &lt; -1.01 ||</span></div><div align="left" style="margin-left:120px;"><span style="color: rgb(0, 128, 0);">         activeControlInfo.linear.x &gt; 1.01 || activeControlInfo.linear.x &lt; -1.01 ||</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">activeControlInfo.linear.y &gt; 1.01 || activeControlInfo.linear.y &lt; -1.01 ||</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);">                  activeControlIn</span> <span style="color: rgb(0, 128, 0);">double tsMillis = timeSpanMicros / 1000.0; // in milliseconds</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">double tsSeconds = tsMillis / 1000.0; // in seconds</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">// predict roll, pitch, yaw</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">float rollControlGain = tsSeconds*c3*(c4 * max(-0.5, min(0.5, (double)activeControlInfo.linear.y)) - roll.state);</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">float pitchControlGain = tsSeconds*c3*(c4 * max(-0.5, min(0.5, (double)activeControlInfo.linear.x)) - pitch.state);</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">float yawSpeedControlGain = tsSeconds*c5*(c6 * activeControlInfo.angular.z - yaw.state[1]); // at adaption to ros, this has to be reverted for some reason....</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">double yawRad = yaw.state[0] * 3.14159268 / 180;</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">double rollRad = roll.state * 3.14159268 / 180;</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">double pitchRad = pitch.state * 3.14159268 / 180;</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">double forceX = cos(yawRad) * sin(rollRad) * cos(pitchRad) - sin(yawRad) * sin(pitchRad);</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">double forceY = - sin(yawRad) * sin(rollRad) * cos(pitchRad) - cos(yawRad) * sin(pitchRad);</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">double vx_gain = tsSeconds * c1 * (c2*forceX - x.state[1]);</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">double vy_gain = tsSeconds * c1 * (c2*forceY - y.state[1]);</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">double vz_gain = tsSeconds * c7 * (c8*activeControlInfo.linear.z*(activeControlInfo.linear.z &lt; 0 ? 2 : 1) - z.state[1]);</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">lastVXGain = vx_gain;</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">lastVYGain = vy_gain;</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">lastPredictedRoll = roll.state;</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">lastPredictedPitch = pitch.state;</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">if(!useControlGains || !controlValid)</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">{</span></div><div align="left" style="margin-left:120px;"><span style="color: rgb(0, 128, 0);">          vx_gain = vy_gain = vz_gain = 0;</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">rollControlGain = pitchControlGain = yawSpeedControlGain = 0;</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">}</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">yaw.state[0] = angleFromTo(yaw.state[0],-180,180);</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">roll.predict(tsMillis,varSpeedError_rp, rollControlGain);</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">pitch.predict(tsMillis,varSpeedError_rp, pitchControlGain);</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">yaw.predict(tsMillis,varAccelerationError_yaw,TooN::makeVector(tsSeconds*yawSpeedControlGain/2,yawSpeedControlGain),1,5*5);</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">yaw.state[0] = angleFromTo(yaw.state[0],-180,180);</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">x.predict(tsMillis,varAccelerationError_xy,TooN::makeVector(tsSeconds*vx_gain/2,vx_gain),0.0001);</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">y.predict(tsMillis,varAccelerationError_xy,TooN::makeVector(tsSeconds*vy_gain/2,vy_gain),0.0001);</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">z.predict(tsMillis,TooN::makeVector(tsSeconds*tsSeconds*tsSeconds*tsSeconds, 9*tsSeconds,tsSeconds*tsSeconds*tsSeconds*3),</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">TooN::makeVector(tsSeconds*vz_gain/2,vz_gain));</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(0, 128, 0);">}</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:360px;"><span style="color: rgb(0, 128, 0);">          ---------------------------------------------------------------------------</span></div><div align="left" style="margin-left:480px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);">(관측치가 더해져야 한다면, [predictTo]와 같은 스탬프를 가져야 함)</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);">(지금 [predictTo]를 timestamp로 설정한 한에서)</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">bool observedXYZ = false, observedRPY=false;</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">if(rpyIterator != navdataQueue-&gt;end() &amp;&amp; getMS(rpyIterator-&gt;header.stamp)-delayRPY == predictTo)</span></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">{</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">if(this-&gt;useNavdata)</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">observeIMU_RPY(&amp;(*rpyIterator));</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">observedRPY = true;</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 128, 0);">//cout &lt;&lt; &quot;a&quot;;</span></div></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">}</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">// </span> <span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">rpyIterator가</span><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">navdataQueue의 마지막 다음지점을 가리키는 반복자와 같지 않고,  rpyIterator의 헤더 스탬프를 밀리초로 바꾼 시각에서 delayRPY를 뺀 시각이 predictTo와 같다면, </span></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);">다시 this의 useNavdata가 참이면 observeIMU_RPY(&amp;(*rpyIterator)) 실행.</span></div><div align="left" style="margin-left:400px;"><font color="#008000">observedRPY에 true 저장.</font></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">if(xyzIterator != navdataQueue-&gt;end() &amp;&amp; getMS(xyzIterator-&gt;header.stamp)-delayXYZ == predictTo)</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">{</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">if(this-&gt;useNavdata)</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">observeIMU_XYZ(&amp;(*xyzIterator));</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">observedXYZ = true;</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 128, 0);">//cout &lt;&lt; &quot;p&quot;;</span></div></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">}</span></div><div align="left" style="font-family:gotham, helvetica, arial, sans-serif;font-size:14px;margin-left:400px;"><span style="color: rgb(0, 0, 0);">// </span> <span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">xyzIterator가</span><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">navdataQueue의 마지막 다음지점을 가리키는 반복자와 같지 않고, xyzIterator의 헤더 스탬프를 밀리초로 바꾼 시각에서 delayXYZ를 뺀 시각이 predictTo와 같다면, </span></span></div><div align="left" style="font-family:&quot;Helvetica Neue&quot;, Arial, sans;font-size:16px;margin-left:400px;"><span style="color: rgb(0, 128, 0);">다시 this의 useNavdata가 참이면 observeIMU_XYZ(&amp;(*xyzIterator)) 실행.</span></div><div align="left" style="font-family:&quot;Helvetica Neue&quot;, Arial, sans;font-size:16px;margin-left:400px;"><font color="#008000">observedXYZ에 true 저장.</font></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">predictdUpToTimestamp = predictTo; <span style="color: rgb(0, 128, 0);">// predictTo를 predictdUpToTimestamp에 저장</span></span></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">if(consume)</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">{</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">if(node-&gt;logfileFilter != NULL)</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">{</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">pthread_mutex_lock(&amp;(node-&gt;logFilter_CS));</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">(*(node-&gt;logfileFilter)) &lt;&lt; predictdUpToTimestamp &lt;&lt; &quot; &quot; &lt;&lt; 0 &lt;&lt; &quot; &quot; &lt;&lt; 0 &lt;&lt; &quot; &quot; &lt;&lt; 0 &lt;&lt; &quot; &quot; &lt;&lt;</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">0 &lt;&lt; &quot; &quot; &lt;&lt; 0 &lt;&lt; &quot; &quot; &lt;&lt; 0 &lt;&lt; &quot; &quot; &lt;&lt;</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">controlIterator-&gt;twist.linear.y &lt;&lt; &quot; &quot; &lt;&lt; controlIterator-&gt;twist.linear.x &lt;&lt; &quot; &quot; &lt;&lt; controlIterator-&gt;twist.linear.z &lt;&lt; &quot; &quot; &lt;&lt; controlIterator-&gt;twist.angular.z &lt;&lt; &quot; &quot; &lt;&lt;</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">(observedRPY ? rpyIterator-&gt;rotX : -1) &lt;&lt; &quot; &quot; &lt;&lt; (observedRPY ? rpyIterator-&gt;rotY : -1) &lt;&lt; &quot; &quot; &lt;&lt; (observedRPY ? lastdYaw : -1) &lt;&lt; &quot; &quot; &lt;&lt;</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">(observedXYZ ? xyzIterator-&gt;vx : -1) &lt;&lt; &quot; &quot; &lt;&lt; (observedXYZ ? xyzIterator-&gt;vy : -1) &lt;&lt; &quot; &quot; &lt;&lt; (observedXYZ ? lastdZ : -1) &lt;&lt; &quot; &quot; &lt;&lt;</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">x.state[0] &lt;&lt; &quot; &quot; &lt;&lt; y.state[0] &lt;&lt; &quot; &quot; &lt;&lt; z.state[0] &lt;&lt; &quot; &quot; &lt;&lt; roll.state &lt;&lt; &quot; &quot; &lt;&lt; pitch.state &lt;&lt; &quot; &quot; &lt;&lt; yaw.state[0] &lt;&lt; &quot; &quot; &lt;&lt; x.state[1] &lt;&lt; &quot; &quot; &lt;&lt; y.state[1] &lt;&lt; &quot; &quot; &lt;&lt; z.state[1] &lt;&lt; &quot; &quot; &lt;&lt; yaw.state[1] &lt;&lt; &quot; &quot; &lt;&lt;</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">lastVXGain &lt;&lt; &quot; &quot; &lt;&lt; lastVYGain &lt;&lt; &quot; &quot; &lt;&lt; &quot;\n&quot;;</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">pthread_mutex_unlock(&amp;(node-&gt;logFilter_CS));</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">}</span></div></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">}</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);">// consume이 True이면, node의 logfileFilter가 NULL이 아니면, </span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);">로그 기록. controlIterator의 {twist.linear.y, <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">twist.linear.x, </span><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">twist.linear.z, </span> <span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">twist.angular.z}, observedRPY가 참이면 rpyIterator의 {rotX, rotY}, lastdYaw, xyzIterator의 {vx, vy}, lastdZ, x.state[0], y.stat[0], z.state[0], roll.state, pitch.state, yaw.state[0], x.state[1], y.state[1], z.state[1], yaw.state[1], lastVXGain, lastVYGain</span></span></div><div align="left" style="margin-left:360px;"><br/></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">if(observedRPY) rpyIterator++; <span style="color: rgb(0, 128, 0);">// observedRPY가 참이면 rpyIterator 1 증가</span></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">if(observedXYZ) xyzIterator++; </span><span style="color: rgb(0, 128, 0);"><span style="font-family: gotham, helvetica, arial, sans-serif; font-size: 14px;">// observedXYZ가 참이면 xyzIterator 1 증가</span></span></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);"><br/></span></div></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);"><br/></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);">(여기가 얻고자 한 위치라면, 종료)</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">if(predictTo == timestamp)</span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">break; <span style="color: rgb(0, 128, 0);">// predictTo와 timestamp가 같다면 break</span></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 0, 0);">} </span></div><div align="left" style="margin-left:80px;"><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">//cout &lt;&lt; endl;</span></div><div align="left" style="margin-left:320px;"><span style="color: rgb(0, 0, 0);">}</span></div></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: '맑은 고딕';font-size:14px;"> </span></span><span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: '맑은 고딕';font-size:14px;">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:400px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:280px;">return scopy.getCurrentPoseSpeed(); <span style="color: rgb(0, 128, 0);">// (값 반환, scopy에 생겨난 모든 변화는 폐기. (삭제)) 카피 scopy의 </span><span style="color: rgb(0, 128, 0);">getCurrentPoseSpeed();</span> <span style="color: rgb(0, 128, 0);">반환</span></div><div align="left" style="margin-left:280px;"><span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: '맑은 고딕';font-size:14px;">                        </span></span> <span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: '맑은 고딕';font-size:14px;">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:400px;">tum_ardrone::filter_state DroneKalmanFilter::getCurrentPoseSpeed()</div><div align="left" style="margin-left:400px;">{</div><div align="left" style="margin-left:400px;">    tum_ardrone::filter_state s;</div><div align="left" style="margin-left:400px;">    s.x = x.state[0];</div><div align="left" style="margin-left:400px;">    s.y = y.state[0];</div><div align="left" style="margin-left:400px;">    s.z = z.state[0];</div><div align="left" style="margin-left:400px;">    s.yaw = yaw.state[0];</div><div align="left" style="margin-left:400px;">    s.dx = x.state[1];</div><div align="left" style="margin-left:400px;">    s.dy = y.state[1];</div><div align="left" style="margin-left:400px;">    s.dz = z.state[1];</div><div align="left" style="margin-left:400px;">    s.dyaw = yaw.state[1];</div><div align="left" style="margin-left:400px;">    s.roll = roll.state;</div><div align="left" style="margin-left:400px;">    s.pitch = pitch.state;</div><div align="left" style="margin-left:400px;"><br/></div><div align="left" style="margin-left:400px;">    if(s.roll*s.roll &lt; 0.001) s.roll = 0;</div><div align="left" style="margin-left:400px;">    if(s.pitch*s.pitch &lt; 0.001) s.pitch = 0;</div><div align="left" style="margin-left:400px;">    if(s.yaw*s.yaw &lt; 0.001) s.yaw = 0;</div><div align="left" style="margin-left:400px;">    if(s.dx*s.dx &lt; 0.001) s.dx = 0;</div><div align="left" style="margin-left:400px;">    if(s.dy*s.dy &lt; 0.001) s.dy = 0;</div><div align="left" style="margin-left:400px;">    if(s.dz*s.dz &lt; 0.001) s.dz = 0;</div><div align="left" style="margin-left:400px;">    if(s.x*s.x &lt; 0.001) s.x = 0;</div><div align="left" style="margin-left:400px;">    if(s.y*s.y &lt; 0.001) s.y = 0;</div><div align="left" style="margin-left:400px;">    if(s.z*s.z &lt; 0.001) s.z = 0;</div><div align="left" style="margin-left:400px;"><br/></div><div align="left" style="margin-left:400px;">    return s;</div><div align="left" style="margin-left:400px;">}</div><div align="left" style="margin-left:280px;"><span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: '맑은 고딕';font-size:14px;">                        </span></span> <span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: '맑은 고딕';font-size:14px;">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:280px;"><span style="color: rgb(0, 128, 0);">}</span></div><div align="left" style="margin-left:80px;"><br/></div><div align="left" style="margin-left:80px;"><br/></div><div align="left" style="margin-left:80px;">pthread_mutex_unlock( &amp;filter-&gt;filter_CS ); // filter의 filter_CS 뮤텍스 잠금 해제</div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:80px;">( 메타데이터 채우기)</div><div align="left" style="margin-left:80px;">s.header.stamp = ros::Time().now(); <span style="color: rgb(50, 135, 18);">// 현재시간을 (tum_ardrone::filter_state의 인스턴스) s의 헤더 스탬프에 저장</span></div><div align="left" style="margin-left:80px;">s.scale = filter-&gt;getCurrentScales()[0]; <span style="color: rgb(50, 135, 18);">// (드론칼만필터 클래스의 인스턴스(포인터)) filter의 현재 스케일 받아와 s의 스케일에 저장</span></div><div align="left" style="margin-left: 80px;">s.scaleAccuracy = filter-&gt;getScaleAccuracy();<span style="color: rgb(50, 135, 18);"> // filter의 스케일 정확도 받아와 s의 스케일 정확도에 저장</span></div><div align="left" style="margin-left:80px;">s.ptamState = ptamWrapper-&gt;PTAMStatus; <span style="color: rgb(50, 135, 18);">// (PTAMWrapper 클래스의 인스턴스(포인터))ptamWapper의 상태status 받아와 s의 ptamState에 저장</span></div><div align="left" style="margin-left:80px;">s.droneState = lastNavdataReceived.state; <span style="color: rgb(50, 135, 18);">// lastNavdataReceived의 state를 s의 드론 상태dronestate로 저장</span></div><div align="left" style="margin-left:80px;">s.batteryPercent = lastNavdataReceived.batteryPercent; <span style="color: rgb(50, 135, 18);">// <span style="font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: -webkit-left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-size: medium; display: inline !important; float: none;">lastNavdataReceived의</span> 배터리 잔량을 s의 배터리 잔량으로 저장</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:80px;">(발행)</div><div align="left" style="margin-left:80px;">dronepose_pub.publish(s); <span style="color: rgb(50, 135, 18);">// &lt;tum_ardrone::filter_state&gt; 타입으로 dronepose_pub 발행자로 s 발행?</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:80px;">(필요하다면 가짜 PTAM 관측치를 추가) 해 큐가 너무 커지지 않도록 할 것)</div><div align="left" style="margin-left:80px;">( PTAM이 비디오가 없거나 초기화 등의 이유로 업데이트되지 않으면 필터는 바뀌지 않으므로 큐가 너무 커짐. 큐가 너무 커지면 가짜 ptam 관측치를 추가해서 이를 방지하라. (500ms = 100 개 관측치)</div><div align="left" style="margin-left:80px;">if((getMS(ros::Time().now()) - filter-&gt;predictdUpToTimestamp) &gt; 500)</div><div align="left" style="margin-left:80px;">filter-&gt;addFakePTAMObservation(getMS(ros::Time().now()) - 300); <span style="color: rgb(0, 128, 0);">// 현재시각 - filter의 predictdUpToTimestamp 가 500ms보다 크면, 필터의 addFakePTAMObservation((현재시각-300)ms) 함수 실행</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:80px;">(새 Info 보내기)</div><div align="left" style="margin-left:80px;">if((ros::Time::now() - lastInfoSent) &gt; ros::Duration(0.4)) </div><div align="left" style="margin-left:80px;">{</div><div align="left" style="margin-left:80px;">reSendInfo(); <span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;">// 현재시각과 lastInfoSent 시각 차이가 0.4초 이상이면 reSendInfo() 함수를 실행</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: '맑은 고딕';font-size:14px;">               -----------------------------------------------------</span></span></div><div align="left" style="margin-left:160px;"><b>reSendInfo()</b></div><div align="left" style="margin-left:160px;">void EstimationNode::reSendInfo()</div><div align="left" style="margin-left:160px;">{</div><div align="left" style="margin-left:160px;"><br/></div><div align="left" style="margin-left:160px;">    (ptam status 문자열 얻어오기)</div><div align="left" style="margin-left:160px;">    std::string ptamStatus;</div><div align="left" style="margin-left:160px;">    switch(ptamWrapper-&gt;PTAMStatus) <span style="color: rgb(50, 135, 18);">// ptamWrapper의 PTAMStatus 가 각각 다음의 경우일 때, ptamStatus에 해당 케이스에 대한 문자열 저장</span></div><div align="left" style="margin-left:160px;">    {</div><div align="left" style="margin-left:160px;">    case PTAMWrapper::PTAM_IDLE:</div><div align="left" style="margin-left:160px;">        ptamStatus = &quot;Idle&quot;; break;</div><div align="left" style="margin-left:160px;">    case PTAMWrapper::PTAM_INITIALIZING:</div><div align="left" style="margin-left:160px;">        ptamStatus = &quot;Initializing&quot;; break;   </div><div align="left" style="margin-left:160px;">    case PTAMWrapper::PTAM_LOST:</div><div align="left" style="margin-left:160px;">        ptamStatus = &quot;Lost&quot;;  break;</div><div align="left" style="margin-left:160px;">    case PTAMWrapper::PTAM_FALSEPOSITIVE:</div><div align="left" style="margin-left:160px;">        ptamStatus = &quot;FalsePositive&quot;;  break;</div><div align="left" style="margin-left:160px;">    case PTAMWrapper::PTAM_GOOD:</div><div align="left" style="margin-left:160px;">        ptamStatus = &quot;Good&quot;;  break;</div><div align="left" style="margin-left:160px;">    case PTAMWrapper::PTAM_TOOKKF:</div><div align="left" style="margin-left:160px;">    case PTAMWrapper::PTAM_BEST:</div><div align="left" style="margin-left:160px;">        ptamStatus = &quot;Best&quot;;  break;</div><div align="left" style="margin-left:160px;">    }</div><div align="left" style="margin-left:160px;"><br/></div><div align="left" style="margin-left:160px;">    (PTAM message 파싱)</div><div align="left" style="margin-left:160px;">    std::string ptamMsg = ptamWrapper-&gt;lastPTAMMessage; <span style="color: rgb(50, 135, 18);">// ptamWrapper의 lastPTAMMessage를 ptamMsg에 저장</span></div><div align="left" style="margin-left:160px;">    int kf, kp, kps[4], kpf[4];</div><div align="left" style="margin-left:160px;">    int pos = ptamMsg.find(&quot;Found: &quot;); <span style="color: rgb(50, 135, 18);">// ptamMsg에서 &quot;Found: &quot;의 위치를 찾아 반환. 검색 실패시 std::string::npos 반환.</span></div><div align="left" style="margin-left:160px;">    int found = 0;</div><div align="left" style="margin-left:160px;">    if(pos != std::string::npos)  </div><div align="left" style="margin-left:160px;">        found = sscanf(ptamMsg.substr(pos).c_str(),&quot;Found: %d/%d %d/%d %d/%d %d/%d Map: %dP, %dKF&quot;,  </div><div align="left" style="margin-left:160px;">                        &amp;kpf[0],&amp;kps[0],&amp;kpf[1],&amp;kps[1],&amp;kpf[2],&amp;kps[2],&amp;kpf[3],&amp;kps[3],&amp;kp,&amp;kf); <span style="color: rgb(50, 135, 18);">// (&quot;Found: &quot; 검색 성공시) ptamMsg의 문자열 &quot;Found: %d/%d %d/%d %d/%d %d/%d Map: %dP, %dKF&quot;을 읽어서, 각각&amp;kpf[0],&amp;kps[0],&amp;kpf[1],&amp;kps[1],&amp;kpf[2],&amp;kps[2],&amp;kpf[3],&amp;kps[3],&amp;kp,&amp;kf에 저장, 읽어들인 갯수는 found에 저장</span></div><div align="left" style="margin-left:160px;">    char bufp[200];</div><div align="left" style="margin-left:160px;">    if(found == 10)</div><div align="left" style="margin-left:160px;">        snprintf(bufp,200,&quot;Map: KF: %d, KP: %d (%d of %d found)&quot;,</div><div align="left" style="margin-left:160px;">                kf, kp,kpf[0]+kpf[1]+kpf[2]+kpf[3], kps[0]+kps[1]+kps[2]+kps[3]); <span style="color: rgb(50, 135, 18);">// (found가 10이면) bufp에, 길이 최대 200, &quot;Map: KF: %d, KP: %d (%d of %d found)&quot;라는 형태로, 각각의 %d에 kf, kp,kpf[0]+kpf[1]+kpf[2]+kpf[3], kps[0]+kps[1]+kps[2]+kps[3] 저장</span></div><div align="left" style="margin-left:160px;">    else</div><div align="left" style="margin-left:160px;">        snprintf(bufp,200,&quot;Map: -&quot;); <span style="color: rgb(50, 135, 18);">// (found가 10이 아니면) bufp에, 길이 최대 200, &quot;Map: -&quot; 형태로 저장</span></div><div align="left" style="margin-left:160px;"><br/></div><div align="left" style="margin-left:160px;">    lastNavdataReceived.batteryPercent;  </div><div align="left" style="margin-left:160px;"><br/></div><div align="left" style="margin-left:160px;">    std::string status = &quot;&quot;;</div><div align="left" style="margin-left:160px;">    switch(    lastNavdataReceived.state) <span style="color: rgb(50, 135, 18);">// lastNavdataReceived의 state가 각각 다음의 경우일 때, status에 해당 케이스에 대한 문자열 저장</span></div><div align="left" style="margin-left:160px;">    {</div><div align="left" style="margin-left:160px;">        case 0: status = &quot;Unknown&quot;;break;</div><div align="left" style="margin-left:160px;">        case 1: status = &quot;Init&quot;; break;</div><div align="left" style="margin-left:160px;">        case 2: status = &quot;Landed&quot;;break;</div><div align="left" style="margin-left:160px;">        case 3: status = &quot;Flying&quot;; break;</div><div align="left" style="margin-left:160px;">        case 4: status = &quot;Hovering&quot;;break;</div><div align="left" style="margin-left:160px;">        case 5: status = &quot;Test&quot;; break;</div><div align="left" style="margin-left:160px;">        case 6: status = &quot;Taking off&quot;;break;</div><div align="left" style="margin-left:160px;">        case 7: status = &quot;Goto Fix Point&quot;; break;</div><div align="left" style="margin-left:160px;">        case 8: status = &quot;Landing&quot;;break;</div><div align="left" style="margin-left:160px;">        case 9: status = &quot;Looping&quot;; break;</div><div align="left" style="margin-left:160px;">    }</div><div align="left" style="margin-left:160px;">   </div><div align="left" style="margin-left:160px;">    char buf[1000];</div><div align="left" style="margin-left:160px;">    snprintf(buf,1000,&quot;u s PTAM: %s\n%s\nScale: %.3f (%d in, %d out), acc: %.2f\nScaleFixpoint: %s\nDrone Status: %s (%d Battery)&quot;,</div><div align="left" style="margin-left:160px;">            ptamStatus.c_str(),</div><div align="left" style="margin-left:160px;">            bufp,</div><div align="left" style="margin-left:160px;">            filter-&gt;getCurrentScales()[0],filter-&gt;scalePairsIn,filter-&gt;scalePairsOut,filter-&gt;getScaleAccuracy(),</div><div align="left" style="margin-left:160px;">            filter-&gt;useScalingFixpoint ? &quot;FIX&quot; : &quot;DRONE&quot;,</div><div align="left" style="margin-left:160px;">            status.c_str(), (int)lastNavdataReceived.batteryPercent); <span style="color: rgb(50, 135, 18);">// buf에, 길이 최대 1000, &quot;u s PTAM: %s\n%s\nScale: %.3f (%d in, %d out), acc: %.2f\nScaleFixpoint: %s\nDrone Status: %s (%d Battery)&quot;라는 형태로, 각각의 %s, %s, %.3f, %d, %d, %.2f, %s, %s, %d에 ptamStatus.c_str(), bufp, filter-&gt;getCurrentScales()[0], filter-&gt;scalePairsIn, filter-&gt;scalePairsOut, filter-&gt;getScaleAccuracy(), filter-&gt;useScalingFixpoint ? &quot;FIX&quot; : &quot;DRONE&quot;, status.c_str(), (int)lastNavdataReceived.batteryPercent 저장</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(45, 79, 201);">cf. buf에 저장된 최종 메시지 형태는 다음과 같음</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(45, 79, 201);">/*</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(45, 79, 201);">PTAM: Idle | Good | Dodgy | Lost</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(45, 79, 201);">Map: KF: X, KP: X (X searched, X found)</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(45, 79, 201);">Scale: X (in: X, out: x), acc: X</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(45, 79, 201);">Scale Fixpoint: NONE | DRONE</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(45, 79, 201);">Status: X (Battery: X)</span></div><div align="left" style="margin-left:160px;"><span style="color: rgb(45, 79, 201);">*/</span></div><div align="left" style="margin-left:80px;">                   publishCommand(buf); // buf 발행</div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: '맑은 고딕';">                                        -----------------------------------------------------</span></span></div><div align="left" style="margin-left:280px;"><span style="color: rgb(50, 135, 18);"><b>publishCommand() 함수</b> (from EstimationNode.cpp)</span></div><div align="left" style="margin-left:280px;">void EstimationNode::publishCommand(std::string c)</div><div align="left" style="margin-left:280px;">{</div><div align="left" style="margin-left:280px;">    std_msgs::String s; </div><div align="left" style="margin-left:280px;">    s.data = c.c_str(); <span style="color: rgb(50, 135, 18);">// 넘겨받은 c를 문자열로 바꿔 std_msgs::String 타입 s의 data에 저장해</span></div><div align="left" style="margin-left:280px;">    pthread_mutex_lock(&amp;tum_ardrone_CS);</div><div align="left" style="margin-left:280px;">    tum_ardrone_pub.publish(s); <span style="color: rgb(50, 135, 18);">// tum_ardrone_pub 발행자로 s를 발행</span></div><div align="left" style="margin-left:280px;">    pthread_mutex_unlock(&amp;tum_ardrone_CS);</div><div align="left" style="margin-left:280px;">}</div><div align="left" style="margin-left:280px;"><span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: '맑은 고딕';">-----------------------------------------------------</span></span></div><div align="left" style="margin-left:80px;">                    }</div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;"><span style="font-family: '맑은 고딕';font-size:14px;">               -----------------------------------------------------</span></span></div><div align="left" style="margin-left:80px;">lastInfoSent = ros::Time::now();<span style="color: rgb(0, 128, 0);"> </span><span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;">// 현재시각을</span> <span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;">lastInfoSent</span> <span style="color: rgb(0, 128, 0);font-family:gotham, helvetica, arial, sans-serif;font-size:14px;">시각으로 저장</span></div><div align="left" style="margin-left:80px;">}</div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);"><br/></span></div><div align="left" style="margin-left:80px;">/////// 4. 발행주기가 돌아올 때까지 대기하기</div><div align="left" style="margin-left:80px;">pub_rate.sleep();</div><div align="left" style="margin-left:80px;">}</div><div align="left" style="margin-left:80px;">}</div><div align="left" style="font-family:gotham, helvetica, arial, sans-serif;font-size:14px;margin-left:80px;"><span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';">-----------------------------------------------------</span></span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101"><br/></font></span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101">  estimator.mapView-&gt;stopSystem(); </font></span> // <span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">mapView 포인터가 가리키는 객체에 대해 stopSystem() 함수 실행. </span></span></div><div align="left"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">                 -----------------------------------------------------</span></span></div><div align="left"><b>                    <span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';">MapView::stopSystem()</span></span></b> <span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';"><b>함수</b></span> <span style="font-family: '맑은 고딕';">(</span><span style="font-family: '맑은 고딕';">from MapView.cpp) <span style="color: rgb(51, 102, 255);"><u><b>시스템 및 각각의 쓰레드 중지 (MapView.h)</b></u></span></span></span></div><div align="left"><span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';">                 void MapView::stopSystem()</span></span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);">{</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);">keepRunning = false;  </span> <span style="color: rgb(50, 135, 18);">// </span><span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">void MapView::run() 실행시 반영됨 </span></span><span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">(</span><span style="font-family: '맑은 고딕';">from MapView.cpp)</span></span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);">join();</span></div><div align="left" style="margin-left:80px;"><span style="color: rgb(0, 128, 0);">}</span></div><div style="margin-left: 240px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">     -----------------------------------------------------</span></span></div><div style="margin-left: 240px;"><span style="color: rgb(50, 135, 18);"><b>     </b></span> <span style="color: rgb(0, 128, 0);">CVD::Thread::join 함수<b><span style="font-family: '맑은 고딕';"> </span></b> <span style="font-family: '맑은 고딕';">(from CVD::Thread)</span>  </span></div><div style="margin-left: 240px;"><span style="color: rgb(0, 128, 0);">     void CVD::Thread::join ()</span></div><div style="margin-left: 240px;"><span style="color: rgb(0, 128, 0);">    </span> <span style="color: rgb(51, 102, 255);">쓰레드가 실제로 종료될 때까지 대기함block. 쓰레드가 무한 루프를 돌면 영원히 대기함.</span></div><div style="margin-left: 200px;"><span style="color: rgb(0, 128, 0);">                                   cf. from &lt;pthread.h&gt; </span> <a href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread_join.html" rev="en_rl_small" style="font-family:gotham, helvetica, arial, sans-serif;font-size:14px;">참고링크</a></div><div style="margin-left: 360px;"><span style="color: rgb(0, 128, 0);">int pthread_join(pthread_t thread, void **value_ptr);</span></div><div align="left" style="margin-left:200px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">             -----------------------------------------------------</span></span></div><div><span style="font-family: '맑은 고딕';"><font color="#010101">estimator.ptamWrapper-&gt;stopSystem();</font></span></div><div align="left"><b>                    <span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';">PTAMWrapper::stopSystem()</span></span></b> <span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';"><span style="color: rgb(0, 128, 0);"><b>함수</b></span></span> <span style="font-family: '맑은 고딕';">(</span><span style="font-family: '맑은 고딕';">from MapView.cpp) <span style="color: rgb(51, 102, 255);"><u><b>시스템 및 각각의 쓰레드 중지 (MapView.h)</b></u></span></span></span></div><div align="left" style="margin-left:80px;"><span style="font-family: '맑은 고딕';">void PTAMWrapper::stopSystem()</span></div><div align="left" style="margin-left:80px;"><span style="font-family: '맑은 고딕';">{</span></div><div align="left" style="margin-left:40px;"><span style="font-family: '맑은 고딕';">          keepRunning = false; </span> <span style="color: rgb(50, 135, 18);">// </span><span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">void PTAMWrapper::run() 실행시 반영됨 </span></span><span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">(</span><span style="font-family: '맑은 고딕';">from PTAMWrapper.cpp)</span></span></div><div style="margin-left:80px;"><span style="font-family: '맑은 고딕';"> new_frame_signal.notify_all(); <span style="color: rgb(0, 128, 0);">/</span></span><span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';">/ 클래스 boost::condition_variable의 인스턴스 </span></span> <span style="color: rgb(0, 128, 0);"><span style="font-family: '맑은 고딕';">new_frame_signal에 대해 동 클래스 멤버 함수 notify_all() 실행.</span></span> <a href="http://www.boost.org/doc/libs/1_61_0/doc/html/thread/synchronization.html#thread.synchronization.condvar_ref.condition_variable.notify_all" rev="en_rl_minimal">참고링크</a></div><div style="margin-left:240px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">     -----------------------------------------------------</span></span></div><div style="margin-left:240px;"><span style="color: rgb(50, 135, 18);"><b>    </b></span> <span style="color: rgb(0, 128, 0);">void notify_all() 함수 </span></div><div style="margin-left:240px;"><span style="color: rgb(0, 128, 0);">     포인터 this가 가리키는 객체(*this)의 wait / timed_wait 함수 호출을 기다리며 현재 대기blocked 상태에 있는 모든 쓰레드의 대기상태를 해제unblock.</span></div><div style="margin-left:120px;"><span style="color: rgb(0, 128, 0);">                              cf. new_frame_signal.wait(lock); 는 PTAMWrapper.cpp::run() 실행시,</span></div><div style="margin-left:80px;"><span style="color: rgb(0, 128, 0);">                                         keepRunning=T이고 newImageAvailable=F일 때 실행</span></div><div align="left" style="margin-left:80px;"><span style="font-family: '맑은 고딕';"> join();</span></div><div align="left" style="margin-left:80px;"><span style="font-family: '맑은 고딕';">}</span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101"><br/></font></span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101">  return 0;</font></span></div><div align="left"><span style="font-family: '맑은 고딕';"><font color="#010101">}</font></span></div><div align="left"><span style="color: rgb(1, 1, 1);"><br/></span></div><div align="left"><span style="color: rgb(1, 1, 1);"><br/></span></div><div align="left"><div><span style="font-family: '맑은 고딕';"><span style="color: rgb(54, 101, 238);">=================================</span></span></div><span style="color: rgb(54, 101, 238);"><b>cf. EstimationNode 구조체</b>: (from EstimationNode.h)</span><div align="left" style="margin-left: 120px;"><div align="left"><span style="font-family: '맑은 고딕';"><span style="color: rgb(1, 1, 1);"><br/></span></span></div><div align="left"><span style="font-family: '맑은 고딕';"><span style="color: rgb(1, 1, 1);">private 변수:</span></span></div></div><div align="left" style="margin-left: 240px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(1, 1, 1);">드론과 소통:</span></span></div><div align="left" style="margin-left: 240px;"><span style="font-family: '맑은 고딕';">    ros::Subscriber <b>navdata_sub</b>; (드론의 navdata) <span style="color: rgb(50, 135, 18);">// navdata_channel 구독</span></span></div><div align="left" style="margin-left: 240px;"><span style="font-family: '맑은 고딕';">    ros::Subscriber <b>vel_sub</b>; (다른 쓰레드로부터의 명령을 함께 받음) <span style="color: rgb(50, 135, 18);">// control_channel 구독(</span></span><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">ControlNode에서</span></span> <span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">&lt;geometry_msgs::Twist&gt;타입으로 발행)</span></span></div><div align="left" style="margin-left: 240px;"><span style="font-family: '맑은 고딕';">    ros::Subscriber <b>vid_sub</b>; <span style="color: rgb(50, 135, 18);">// video_channel 구독</span></span></div><div align="left" style="margin-left: 120px;"><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    ros::Time <b>lastNavStamp</b>;</span></div></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left: 240px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(1, 1, 1);">PTAM과 소통:</span></span></div><div align="left" style="margin-left: 120px;"><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    //ros::Subscriber slam_info_sub; (ptam 정보 등)</span></div></div><div align="left" style="margin-left: 240px;"><span style="font-family: '맑은 고딕';">    //tf::TransformListener tf_sub;</span></div><div align="left" style="margin-left: 240px;"><span style="font-family: '맑은 고딕';">    ros::Subscriber <b>tum_ardrone_sub</b>; <span style="color: rgb(50, 135, 18);">// command_channel 구독</span></span></div><div align="left" style="margin-left: 240px;"><span style="font-family: '맑은 고딕';">    ros::Publisher <b>tum_ardrone_pub</b>; </span><span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">// &lt;std_msgs::String&gt;타입으로 command_channel 발행 (</span></span><span style="font-family: '맑은 고딕';"><span style="color: rgb(50, 135, 18);">ControlNode에서도 발행함)</span></span></div><div align="left" style="margin-left: 240px;"><span style="font-family: '맑은 고딕';">    static pthread_mutex_t <b>tum_ardrone_CS</b>; <span style="color: rgb(50, 135, 18);">// 뮤텍스 tum_ardrone_CS 생성</span></span></div><div align="left" style="margin-left: 120px;"><div align="left"><span style="font-family: '맑은 고딕';"><span style="color: rgb(1, 1, 1);"><br/></span></span></div></div><div align="left" style="margin-left: 240px;"><span style="font-family: '맑은 고딕';"><span style="color: rgb(1, 1, 1);">아웃풋:</span></span></div><div align="left" style="margin-left: 240px;"><span style="font-family: '맑은 고딕';">    ros::Publisher <span style="color: rgb(45, 79, 201);"><b>dronepose_pub</b></span>; </span><span style="color: rgb(50, 135, 18);"><span style="font-family: '맑은 고딕';">// &lt;tum_ardrone::filter_state&gt;타입으로 output_channel 발행(ControlNode에서 구독)</span></span></div><div align="left" style="margin-left: 120px;"><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    ros::NodeHandle <span style="color: rgb(45, 79, 201);"><b>nh_</b></span>;</span></div></div></div><div align="left" style="margin-left:240px;"><span style="font-family: '맑은 고딕';">    tf::TransformBroadcaster <b>tf_broadcaster</b>;</span></div><div align="left" style="margin-left:200px;"><span style="font-family: '맑은 고딕';">         (매 발행 시간[publishFreq]ms마다, 노드는 드론의 향후 예상 시간[predTime]ms에서의 예상 위치를 발행. 이 포즈pose는 드론 조종에 사용될 수 있음. 예상시간이 커질수록 예측치의 정확도도 떨어짐. /tf와, 더 상세하게는 /ardrone/predictedPose에서 발행.)</span></div><div align="left"><div align="left" style="margin-left: 120px;"><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    ros::Duration <b>predTime</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    int <b>publishFreq</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    std::string <b>navdata_channel</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    std::string <b>control_channel</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    std::string <b>output_channel</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    std::string <b>video_channel</b>;</span></div></div><div align="left" style="margin-left: 240px;"><span style="font-family: '맑은 고딕';">    std::string <b>command_channel</b>;</span></div><div align="left" style="margin-left: 200px;"><span style="font-family: '맑은 고딕';">        (navdata의 시간축 변화를 부드럽게time-smoothing 하기 위한)</span></div><div align="left" style="margin-left: 120px;"><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    long <b>lastDroneTS</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    long <b>lastRosTS</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    long <b>droneRosTSOffset</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    ardrone_autonomy::Navdata <b>lastNavdataReceived</b>; (마지막으로 받은 navdata)</span></div><div><span style="font-family: '맑은 고딕';">public <span style="color: rgb(1, 1, 1);">변수:</span></span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">(필터)</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    DroneKalmanFilter* <b>filter</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    PTAMWrapper* <b>ptamWrapper</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    MapView* <b>mapView</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    std::string <b>packagePath</b>;</span></div></div><div align="left" style="margin-left: 240px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left: 240px;"><span style="font-family: '맑은 고딕';">    EstimationNode(); <span style="color: rgb(50, 135, 18);">// 생성자. 반환형은 없지만 함수. 선언부(정의는 EstimationNode.cpp에 있음). 해당 클래스의 인스턴스 생성시 최초로 한번만 실행됨.</span></span></div><div align="left" style="margin-left: 240px;"><span style="font-family: '맑은 고딕';">    ~EstimationNode(); <span style="color: rgb(50, 135, 18);">// 소멸자. 반환형은 없지만 함수. 선언부(정의는 EstimationNode.cpp에 있음). 해당 함수 종료시나 프로그램 종료시 실행됨.</span></span></div></div><div align="left" style="margin-left:120px;"><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">(ROS 메시지 콜백함수들)</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    void <b>navdataCb</b>(const ardrone_autonomy::NavdataConstPtr navdataPtr);</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    void <b>velCb</b>(const geometry_msgs::TwistConstPtr velPtr);</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    void <b>vidCb</b>(const sensor_msgs::ImageConstPtr img);</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    void <b>comCb</b>(const std_msgs::StringConstPtr str);</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    void <b>dynConfCb</b>(tum_ardrone::StateestimationParamsConfig &amp;config, uint32_t level);</span></div></div><div align="left" style="margin-left:240px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left:240px;"><span style="font-family: '맑은 고딕';">    void <b>Loop</b>(); (포즈를 예측하는pose-estimation 메인 루프)</span></div><div align="left" style="margin-left:120px;"><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    void <b>publishCommand</b>(std::string c); (&quot;/tum_ardrone/com&quot;에 메시지 쓰기 위함. 쓰레드에 안전(어느 쓰레드든 호출할 수 있으나 호출한 쓰레드가 끝날 때까지 블록됨))</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    void <b>reSendInfo</b>();</span></div><div align="left" style="margin-left:80px;"><span style="font-family: '맑은 고딕';">            void <b>publishTf</b>(TooN::SE3&lt;&gt;, ros::Time stamp, int seq, std::string system);</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">(로그 관련)</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    std::ofstream* <b>logfileIMU</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    std::ofstream* <b>logfilePTAM</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    std::ofstream* <b>logfileFilte</b>r;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    std::ofstream* <b>logfilePTAMRaw</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    static pthread_mutex_t <b>logIMU_CS</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    static pthread_mutex_t <b>logPTAM_CS</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    static pthread_mutex_t <b>logFilter_CS</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    static pthread_mutex_t <b>logPTAMRaw_CS</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    long <b>currentLogID</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    ong <b>startedLogClock</b>;</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    void <b>toogleLogging</b>(); (로그 기록 여부 on/off)</span></div><div align="left" style="margin-left:120px;"><span style="font-family: '맑은 고딕';">    std::string <b>calibFile</b>;</span></div></div><div align="left" style="margin-left: 240px;"><span style="font-family: '맑은 고딕';">    int <b>arDroneVersion</b>;</span></div><div align="left" style="margin-left: 240px;"><br/></div><div align="left" style="margin-left: 240px;"><br/></div><div align="left"><span style="font-family: '맑은 고딕';"><span style="color: rgb(54, 101, 238);">=================================</span></span><div><span style="font-family: '맑은 고딕';"><b><span style="color: rgb(54, 101, 238);">cf. PTAMWrapper 클래스: (from PTAMWrapper.h)   </span></b></span><span style="font-family: '맑은 고딕';">private CVD::Thread, private MouseKeyHandler</span></div><div><span style="color: rgb(88, 152, 255);">PTAM에서는 카메라의 위치를 추적하는 tracking 부분과 특징맵을 생성하는 mapping 부분을 서로 분리시켜서 별도의 쓰레드(thread)로 parallel하게 돌린다. 그래서 둘 사이의 종속성을 없애고 실시간성과 정확도를 동시에 만족시킬 수 있는 새로운(획기적인) 방법을 사용한다. 그 핵심 아이디어는 비교적 연산로드가 적은 카메라 tracking은 모든 영상프레임에 적용하여 실시간성을 추구하고, 맵 갱신은 주요 키프레임에만 적용하되 시간이 오래 걸리더라도 정밀한 알고리즘을 사용하여 정확도를 추구한 점에 있다.  </span><a href="http://darkpgmr.tistory.com/129" rev="en_rl_minimal">http://darkpgmr.tistory.com/129</a></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div><span style="font-family: '맑은 고딕';"><span style="color: rgb(1, 1, 1);">private 변수:</span></span></div><div align="left" style="text-align: -webkit-auto; margin-left: 120px;">(기본창)</div><div align="left" style="text-align: -webkit-auto; margin-left: 120px;"><span style="font-family: '맑은 고딕';">    GLWindow2* myGLWindow;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    CVD::ImageRef desiredWindowSize; </span><span style="font-family: '맑은 고딕';">(</span><span style="font-family: '맑은 고딕';">changeSizeNextRender가 True일 때 바뀌는 창 사이즈)</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    CVD::ImageRef defaultWindowSize; (기본으로 열리는 창 사이즈)</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    bool <b>changeSizeNextRender</b>;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">(연관associated 쓰레드 실행 함수. </span><span style="font-family: '맑은 고딕';">HandleFrame() 호출 시마다 새로운 프레임 사용 가능)</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    void <b>run</b>();</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    void HandleFrame();</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">(필터 참조)</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    DroneKalmanFilter* filter;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    EstimationNode* node;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">(PTAM 관련)</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    char charBuf[1000];</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    std::string msg;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    CVD::Image&lt;CVD::byte&gt; mimFrameBW;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    CVD::Image&lt;CVD::byte&gt; mimFrameBW_workingCopy;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    int mimFrameTime;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    int mimFrameTime_workingCopy;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    unsigned int mimFrameSEQ;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    unsigned int mimFrameSEQ_workingCopy;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    ros::Time mimFrameTimeRos;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    ros::Time mimFrameTimeRos_workingCopy;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    int frameWidth, frameHeight;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">// Map is in my global Coordinate system. keyframes give the front-cam-position, i.e.</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">// CFromW is &quot;GlobalToFront&quot;. this is achieved by aligning the global coordinate systems in the very beginning.</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    Map *mpMap;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    MapMaker *mpMapMaker;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    Tracker *mpTracker;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    ATANCamera *mpCamera;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    Predictor* predConvert;            // used ONLY to convert from rpy to se3 and back, i.e. never kept in some state.</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    Predictor* predIMUOnlyForScale;    // used for scale calculation. needs to be updated with every new navinfo...</span> <span style="font-family: '맑은 고딕';">                 double minKFTimeDist;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    double minKFWiggleDist;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    double minKFDist;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    Predictor* imuOnlyPred;   </span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    int lastScaleEKFtimestamp;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    bool resetPTAMRequested;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    enum {UI_NONE = 0, UI_DEBUG = 1, UI_PRES = 2} drawUI;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    bool forceKF;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    bool flushMapKeypoints;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    int lastAnimSentClock;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    enum {ANIM_NONE, ANIM_TOOKKF, ANIM_GOOD, ANIM_INIT, ANIM_LOST, ANIM_FALSEPOS} lastAnimSent;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">//int lastGoodPTAM;    /// approx. timestamp of last good ptam observation... inaccurate!</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    int lastGoodYawClock;  </span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    int isGoodCount;    // number of succ. tracked frames in a row.</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    TooN::Vector&lt;3&gt; PTAMPositionForScale;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    int ptamPositionForScaleTakenTimestamp;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    int framesIncludedForScaleXYZ;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    std::deque&lt;ardrone_autonomy::Navdata&gt; navInfoQueue;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    bool navQueueOverflown;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    TooN::Vector&lt;3&gt; evalNavQue(unsigned int from, unsigned int to, bool* zCorrupted, bool* allCorrupted, float* out_start_pressure, float* out_end_pressure);</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">(실행 유지)</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    bool <b>keepRunning</b>;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    bool lockNextFrame;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    boost::condition_variable  new_frame_signal;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    boost::mutex new_frame_signal_mutex;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">(PTAM 트래킹 리셋)</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    void ResetInternal(); </span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    void renderGrid(TooN::SE3&lt;&gt; camFromWorld);</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    int videoFramePing;</span> <span style="font-family: '맑은 고딕';">    std::ofstream* logfileScalePairs;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    static pthread_mutex_t logScalePairs_CS; //pthread_mutex_lock( &amp;cs_mutex );</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div><span style="font-family: '맑은 고딕';"><span style="color: rgb(1, 1, 1);">public 변수:</span></span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    PTAMWrapper(DroneKalmanFilter* dkf, EstimationNode* nde); (생성자)</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    ~PTAMWrapper(void); (소멸자)</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">(ROS에만 해당. 새 image/navdata를 받으면 외부 쓰레드에 의해 호출됨. 싱크 등을 고려</span><span style="font-family: '맑은 고딕';">takes care of sync etc</span><span style="font-family: '맑은 고딕';">)</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    void newImage(sensor_msgs::ImageConstPtr img);</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    void newNavdata(ardrone_autonomy::Navdata* nav);</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    bool newImageAvailable;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    void setPTAMPars(double minKFTimeDist, double minKFWiggleDist, double minKFDist);</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    bool handleCommand(std::string s);</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    bool mapLocked;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    int maxKF;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    static pthread_mutex_t navInfoQueueCS; //pthread_mutex_lock( &amp;cs_mutex );</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    static pthread_mutex_t shallowMapCS; //pthread_mutex_lock( &amp;cs_mutex );</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    // Event handling routines.</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    // get called by the myGLWindow on respective event.</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    virtual void on_key_down(int key);</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    //virtual void on_mouse_move(CVD::ImageRef where, int state);</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    virtual void on_mouse_down(CVD::ImageRef where, int state, int button);</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    //virtual void on_event(int event);</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">(PTAM 트래킹 리셋)</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    inline void Reset() {resetPTAMRequested = true;};</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">(시스템 및 각각의 쓰레드를 실행/중지)</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    void <b>startSystem</b>();</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    void <b>stopSystem</b>();</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    enum {PTAM_IDLE = 0, PTAM_INITIALIZING = 1, PTAM_LOST = 2, PTAM_GOOD = 3, PTAM_BEST = 4, PTAM_TOOKKF = 5, PTAM_FALSEPOSITIVE = 6} PTAMStatus;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    TooN::SE3&lt;&gt; lastPTAMResultRaw;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    std::string lastPTAMMessage;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">(맵 렌더링: 얕은 복사shallow clone)</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    std::vector&lt;tvec3&gt; mapPointsTransformed;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    std::vector&lt;tse3&gt; keyFramesTransformed;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    ardrone_autonomy::Navdata lastNavinfoReceived;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';">    int PTAMInitializedClock;</span></div><div align="left" style="margin-left: 120px;"><span style="font-family: '맑은 고딕';"><br/></span></div></div><div><span style="font-family: '맑은 고딕';"><span style="color: rgb(54, 101, 238);">=================================</span></span></div></span>
</div></body></html> 