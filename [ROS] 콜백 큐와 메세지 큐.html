<html>
<head>
  <title>[ROS] 콜백 큐와 메세지 큐?</title>
  <basefont face="나눔고딕" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303244 (ko-KR, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 나눔고딕;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1671"/>
<h1>[ROS] 콜백 큐와 메세지 큐?</h1>

<div>
<span><div>결론!</div><div><br/></div><div>내부적으로 배후에서 돌아가는 매커니즘을 낱낱이 알 수는 없었으나,</div><div>표면적으로는 콜백 큐와 메세지 큐를 구별할 필요는 없는 듯.</div><div><br/></div><div>예상하기로는 콜백 큐 = 메세지 큐 = 섭스크라이버 큐는 모두 같은 큐이다.</div><div><br/></div><div>구독자 노드가 메세지 하나를 받을 때마다, 그 메세지가 (어떤 매개변수 형태로) '어떤 콜백'을 호출하는지를 확인하여 글로벌 큐에 추가한다.</div><div>메세지가 </div><div><br/></div><div>spinOnce 메소드를 실행하면 한번에 큐에 있는 모든 메세지를 콜백으로 보내어 실행.</div><div><hr/></div><div><b><br/></b></div><div><a href="http://answers.ros.org/question/53055/ros-callbacks-threads-and-spinning/">http://answers.ros.org/question/53055/ros-callbacks-threads-and-spinning/</a></div><div><br/></div><div>roscpp 통신에서 콜백을 핸들링하는 객체는 다음 두가지 이다.</div><ul><li><a href="http://ros.org/doc/groovy/api/roscpp/html/classros_1_1CallbackQueue.html">callback queues</a></li><li><a href="http://ros.org/doc/groovy/api/roscpp/html/classros_1_1Spinner.html">spinners</a></li></ul><div><br/></div><div>스피너는 콜백 큐에 들어있는 콜백을 호출할 수 있는 객체이다.</div><div>각각의 구독자는 메세지 한개를 받을 때마다 콜백 큐에 요소를 추가한다.</div><div>어떤 메세지가 어떤 콜백을 어떤 매개변수로 호출할 것인지를 매핑시키는 작업.</div><div><br/></div><div><b>싱글 스레드 스피너</b></div><div>기본 값. 콜백 큐에 있는 메시지들을 가져다가 하나씩(one by one) 콜백을 처리한다.</div><div>콜백 처리 중에는 콜백을 호출한 스레드의 실행이 블록된다.</div><div><br/></div><div><b>멀티 스레드 스피너</b></div><div>두세개 정도(설정 가능)의 스레드를 돌려서 메세지들을 받았을때 병렬로 콜백을 실행한다.</div><div>콜백이 처리 중인 동안에 그 콜백을 호출한 스레드는 실행이 블록된다.</div><div><br/></div><div><b>비동기 스피너</b></div><div>두세개 정도(설정 가능)의 스레드를 돌려서 메세지들을 받았을때 병렬로 콜백을 실행한다.</div><div>콜백이 처리 중인 동안에 그 콜백을 호출한 스레드의 실행은 블록되지 않는다.</div><div>start/stop 메소드로 언제 콜백이 프로세스를 시작하고 멈출지를 정해준다.</div><div><br/></div><div>이러한 객체들은 직접 개발자에 의해 인스턴스가 생성되어 사용될 수도 있지만,</div><div>번거로움과 코드의 장황함을 피하기 위해 객체 없이도 이러한 기능을 제공하는 대체 API가 ROS 네임스페이스 내부에 존재한다.</div><div>이 것이 바로 ros::spin()과 ros::spinOnce()이다.</div><div>이 API들은 싱글 스레드를 사용하는 기본 콜백 큐를 사용한다.</div><div>(기본 글로벌 큐는 수동으로는 ros::getGlobalCallbackQueue() 함수를 통해 접근 가능하다.)</div><div><br/></div><div>*각각의 Node handle은 그에 딸린 콜백 큐를 갖는다. 기본적으로 전역으로 선언되어 있음.</div><div>(같은 노드핸들에서 만들어진 구독자의 경우 동일한 전역적 콜백 큐를 공유하는 듯)</div><div>getCallbackQueue/setCallbackQueue 메소드를 사용하여 오버라이딩 가능.</div><div><br/></div><div><hr/></div><div><br/></div><div><a href="http://answers.ros.org/question/11887/significance-of-rosspinonce/">http://answers.ros.org/question/11887/significance-of-rosspinonce/</a></div><div><br/></div><div>roscpp는 개발자가 많은 송수신과 동시에 발생하는 테스크들을 라이브러리로 추상화해버려서</div><div>그런 것들을 일일이 신경쓸 필요없이 배후에서 처리해주도록 하는 기능을 제공한다.</div><div>roscpp는 &quot;프레임워크가 아닌, 툴박스&quot;라는 철학을 가지고 있다.</div><div>당신의 노드에 특정한 스레딩 모델을 강요하지도 않고 당신의 main()문을 감싸버리지도 않는다.</div><div>roscpp는 네트워크 관리를 위해 뒷 단에서 쓰레드를 사용할지도 모르지만,</div><div>절대로 당신의 프로그램상에서 스레드를 직접 노출시키지 않는다.</div><div>그러면서도 당신이 원한다면 콜백처리를 위해 다수의 스레드를 원하는 개수만큼 사용할 수도 있게 해준다.</div><div><br/></div><div>예를 들어, 백그라운드에서 ROS는 당신이 구독하고자 하는 모든 토픽에 대한 소켓 연결을 주시하고 있다.</div><div>그러다가 메세지가 도착하면, ROS는 당신의 구독자 콜백을 바로 호출하지 않고 일단 큐에 푸쉬한다.</div><div>ROS는 당신이 ros::spinOnce() 명령어를 주었을 때만 당신의 콜백들을 처리한다.</div><div>ros::spin()은 단순히 편의를 위한 것으로 당신의 노드가 셧다운 될 때까지 반복해서 ros::spinOnce()를 호출함으로써,</div><div>ROS의 메인루프와 같은 역할을 한다.</div><div><br/></div><div>ros::spinOnce()를 직접적으로 호출하게 되는 경우의 예는 다음과 같다.</div><div><br/></div><div><b>- 특정 시간 주기로 콜백을 처리하고자 하는 경우</b></div><div>드물긴 하지만, 특정 시간 간격으로 ROS 콜백들을 처리하고자 할 수도 있다. </div><div>이때는 당신의 구독자 큐를 고려해야 한다. 만약 메세지가 100hz로 도착하는데, 당신이 5hz마다 ros::spinOnce()를 호출하고,</div><div>당신의 구독자의 queue_size가 1개라면, 당신은 100개 중에 5개의 메세지만 처리하고 95개는 드랍할 것이다!</div><div>이 것은 당신이 원하는 결과일 수도, 그렇지 않을 수도 있다. 보통은 주기적 처리를 위해서는 Timer를 사용하는 것이 좋다.</div><div><br/></div><div><b>- ROS 콜백으로 처리할 수 없는 다른 프로세스를 수행하고자 하는 경우</b></div><div>만약 자체적인 비동기식 이벤트 프로세싱을 갖는 다른 라이브러리를 사용할 경우,</div><div style="font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-size: 12.025px; margin: 0px 0px 18px; padding: 2px; color: rgb(51, 51, 51); border-radius: 4px; display: block; border: 1px solid rgb(136, 136, 136); clear: both; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(245, 245, 245);"><div><span style="color: rgb(0, 0, 0);"><span style="background-color: transparent;">ros</span></span><span style="color: rgb(102, 102, 0);"><span style="background-color: transparent;">::</span></span><span style="color: rgb(102, 0, 102);"><span style="background-color: transparent;">Rate</span></span><span style="color: rgb(0, 0, 0);"><span style="background-color: transparent;"> r</span></span><span style="color: rgb(102, 102, 0);"><span style="background-color: transparent;">(</span></span><span style="color: rgb(0, 102, 102);"><span style="background-color: transparent;">100</span></span><span style="color: rgb(102, 102, 0);"><span style="background-color: transparent;">);</span></span></div><div><span style="color: rgb(0, 0, 136);"><span style="background-color: transparent;">while</span></span><span style="color: rgb(0, 0, 0);"><span style="background-color: transparent;"> </span></span><span style="color: rgb(102, 102, 0);"><span style="background-color: transparent;">(</span></span><span style="color: rgb(0, 0, 0);"><span style="background-color: transparent;">ros</span></span><span style="color: rgb(102, 102, 0);"><span style="background-color: transparent;">::</span></span><span style="color: rgb(0, 0, 0);"><span style="background-color: transparent;">ok</span></span><span style="color: rgb(102, 102, 0);"><span style="background-color: transparent;">())</span></span><span style="color: rgb(102, 102, 0);"><span style="background-color: transparent;">{</span></span></div><code style="font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-size: 12px; padding: 0px; color: inherit; border-radius: 3px; border: 0px; clear: both; background-color: transparent;"><span style="color: rgb(0, 0, 0);">  libusb_handle_events_timeout</span><span style="color: rgb(102, 102, 0);">(...);</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(136, 0, 0);">// Handle USB events</span><span style="color: rgb(0, 0, 0);"><br/>
  ros</span><span style="color: rgb(102, 102, 0);">::</span><span style="color: rgb(0, 0, 0);">spinOnce</span><span style="color: rgb(102, 102, 0);">();</span><span style="color: rgb(0, 0, 0);">                   </span><span style="color: rgb(136, 0, 0);">// Handle ROS events</span></code><div><span style="color: rgb(0, 0, 0);"><span style="background-color: transparent;">  r</span></span><span style="color: rgb(102, 102, 0);"><span style="background-color: transparent;">.</span></span><span style="color: rgb(0, 0, 0);"><span style="background-color: transparent;">sleep</span></span><span style="color: rgb(102, 102, 0);"><span style="background-color: transparent;">();</span></span></div><div><span style="color: rgb(102, 102, 0);"><span style="background-color: transparent;">}</span></span></div></div><div><b>- GUI나 게임 프로그래밍 등을 위한 다른 프레임워크와 통합하고자 하는 경우</b></div><div><br/></div><div><hr/></div><div><br/></div><div><a href="http://wiki.ros.org/roscpp/Overview/Publishers%20and%20Subscribers">http://wiki.ros.org/roscpp/Overview/Publishers%20and%20Subscribers</a></div><div><br/></div><div><span style="font-size: 19px;"><b>[발행] publish()의 동작과 큐잉</b></span></div><div><br/></div><div>roscpp의 publish()는 비동기적이며, <span style="color: rgb(222, 87, 0);">토픽에 연결된 구독자가 있을 때만 작동한다.</span></div><div>publish() 자체는 매우 빨라야하므로, 최대한 적은 일을 수행한다.</div><div><br/></div><ol><li>보낼 메세지를 버퍼에 직렬화(serialize)한다.</li><li>추후 프로세싱을 위해 그 버퍼를 큐에 밀어넣는다.</li></ol><div><br/></div><div>큐에 밀어넣은 메세지는 <span style="color: rgb(227, 0, 0);">그 이후 roscpp의 내부 스레드에 의해 가능한 빨리 처리</span>된다.</div><div>메세지들은 각각의 연결된 구독자들에게 보내기 위한 또다른 큐에 전달된다.</div><div>이 두번째 큐들의 size가 바로 advertise() 메소드에서 queue_size 파라미터로 설정해준 값이다.</div><div>*전송 단계에서 TCP/UDP 전송 버퍼와 같은 OS레벨의 큐가 추가로 존재할 수도 있는 점에 주의.</div><div><br/></div><div><br/></div><div><span style="font-size: 19px;"><b>[구독] 큐잉과 게으른 역직렬화</b></span></div><div><br/></div><div>토픽에 대한 메세지 하나가 처음 도착하면, queue_size 파라미터에서 명시한 크기를 갖는 큐에 집어 넣는다.</div><div>만약에 큐가 꽉차있을 때, 새 메세지가 도착하면, 가장 오래된 메세지부터 버린다.</div><div>메세지는 그 메세지를 필요로하는 호출되기 직전까지는 사실상 역직렬화 (버퍼(바이트배열) -&gt; 메세지(구조체))되지 않는다.</div><div><br/></div><div><b><span style="color: rgb(79, 0, 154);">*직렬화(Serialization) / 마셜링(marshalling)</span></b></div><div>네트워크를 가로지르는 메세지들은 단순한 바이트의 나열로 눌러담아서 보내야 한다.</div><div>데이터를 바이트 단위로 직선으로 쭉 나열한다고 해서 이를 직렬화라고 한다. 모으고 결집시키다의 의미인 마셜링이라고도 함.</div><div>(컨테이너를 컨테이너선으로부터 선적하거나 양륙하기 위하여 정렬시켜 놓는 작업을 마셜링이라고도 한다.)</div><div>IP나 TCP/UDP는 이러한 데이터 타입을 전혀 모른다. 연속된 바이트의 흐름으로 볼 뿐이다.</div><div>플랫폼에 상관없이 데이터를 주고 받을 수 있으나, 보내고 받을때 데이터의 변환 과정이 필요하다.</div><div>다시 플랫폼에 맞는 복잡한 구조체로 되돌리는 과정을 역직렬화(deserializtion) / 언마셜링(unmarshalling)이라고 한다.</div><div><br/></div><div>ROS에서의..</div><div>- 직렬화 / 마셜링 : 메세지 구조체   ----&gt;  바이트 스트림</div><div>- 역직렬화 / 언마셜링 : 바이트 스트림 ----&gt; 메세지 구조체</div><div><img src="[ROS] 콜백 큐와 메세지 큐_files/sh7sY6HFeJJgS3VHYHQaJ2Q.png" type="image/png" style="height: auto;"/></div><div><a href="http://blog.naver.com/ddowner/220393955950">http://blog.naver.com/ddowner/220393955950</a></div><div><a href="http://blog.naver.com/njh0602/220702224844">http://blog.naver.com/njh0602/220702224844</a></div><div><a href="http://egloos.zum.com/blockboys2/v/231419">http://egloos.zum.com/blockboys2/v/231419</a></div><div><hr/></div><div><br/></div><div><a href="http://wiki.ros.org/roscpp/Overview/Callbacks%20and%20Spinning">http://wiki.ros.org/roscpp/Overview/Callbacks%20and%20Spinning</a></div><div><br/></div><div>고급 : 다른 콜백 큐 사용하기</div><div><br/></div><div>기본값으로, 모든 콜백은 글로벌 큐에 할당되고, 나중에 spin이나 spinOnce에 의해 처리된다. roscpp는 사용자 콜백 큐를 할당하고 실행하는 것을</div><div><br/></div><div><hr/></div><div><br/></div><div><b>[Book] A Gentle Introduction to ROS</b></div><div><a href="https://cse.sc.edu/~jokane/agitr/">https://cse.sc.edu/~jokane/agitr/</a></div><div><br/></div><div><br/></div><div><span style="font-size: 19px;"><b>NodeHandle 객체 생성</b></span></div><div><br/></div><div>내부적으로, NodeHandle 클래스는 참조 카운트를 가지고 있으며 오직 첫번째 노드핸들 오브젝트를 생성할때만 </div><div>마스터에 새로운 노드를 등록한다. 비슷하게, 모든 노드핸들 객체가 소멸하는 시점에 마스터에 등록이 해제된다.</div><div>이 사실로부터 두 가지를 말할 수 있다.</div><div>첫째, 만약 당신이 원한다면, 여러 개의 노드핸들 객체를 생성할 수는 있다, 단, 이들은 모두 같은 노드를 참조한다.</div><div>이렇게 하나의 프로그램 안에서 다수의 노드핸들 객체를 생성하야할 경우가 가끔 있다.</div><div>예를 들어, 특정한 기본 네임스페이스를 지정하여 노드핸들 객체를 생성하는 경우.(129페이지)</div><div>둘째, 표준 roscpp 인터페이스를 사용하는 한, 하나의 프로그램에서 여러개의 개별 노드를 실행하는 것은 불가능하다는 것이다.</div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 19px;"><b>발행자의 큐 사이즈</b></span></div><div><br/></div><div>advertise()의 queue_size 파라미터는 해당 발행자를 위한 메세지 큐의 정수형 크기를 나타낸다.</div><div>대부분의 경우, 1000과 같은 충분히 큰 값이 적당하다.</div><div>만약 당신의 프로그램이 큐가 담을 수 있는 크기에 비해 더 많은 메세지를 보내려고 하면,</div><div>아직 보내지 못한 메시지 중에 가장 오래된 메시지부터 버리기 시작한다.</div><div><br/></div><div>대부분의 경우 메세지는 다른 노드로 전송되어야 하기 때문에 그 과정에서 큐가 필요하다.</div><div>메세지를 만드는 작업에 비해서 메세지를 보내는 작업이 상대적으로 시간이 많이 걸리기 때문에,</div><div>ROS는 이러한 딜레이를 줄이기 위한 방법을 사용한다.</div><div><span style="color: rgb(222, 87, 0);">publish()메소드는 &quot;임시보관&quot; 큐에 저장만 하고 곧바로 돌아온다.</span></div><div><span style="color: rgb(227, 0, 0);">실제로 메세지를 전송하는 일은 배후에서 작동하는 개별적인 스레드들이 담당하게 된다.</span></div><div>queue_size 파라미터에 들어가는 정수형 값이 바로 여기서 말하는 메세지 큐가 담을 수 있는 메세지의 개수이다.</div><div><br/></div><div>흥미롭게도 ROS 클라이언트 라이브러리(roscpp, rospy)는 구독자와 발행자 노드가 같은 상위 프로세스에 속해 있을때</div><div>그 것을 알아챌 수 있다. 이러한 경우에 메세지는 네트워크 통신을 거치지 않고 곧바로 구독자에게 전달된다.</div><div>이러한 특징은 nodelets(단일 프로세스에 동적으로 로드될 수 있는 여러 노드들)를 효율적으로 만들기 위해</div><div>매우 중요한 역할을 한다.</div><div><br/></div><div><i><span style="color: rgb(121, 121, 121);">메세지를 적당한 주기로 보내기 위해 고의적으로 딜레이를 주는 것이 필요할 때가 있다.</span></i></div><div><i><span style="color: rgb(121, 121, 121);">프로그램이 컴퓨터 성능을 최대한 사용하여 메세지를 발행한다면, 발행자와 구독자의 큐가 이를 감당할 수도 없을 것이고,</span></i></div><div><i><span style="color: rgb(121, 121, 121);">컴퓨터 하드웨어 자원과 네트워크 리소스를 낭비하게될 것이다.</span></i></div><div><br/></div><div><br/></div><div><span style="font-size: 19px;"><b>구독자의 큐 사이즈</b></span></div><div><br/></div><div>subsrcribe()의 queue_size 파라미터는 해당 구독자를 위한 메세지 큐의 정수형 크기를 나타낸다.</div><div>대부분의 경우, 1000과 같이 큰 값을 사용해주면 큐잉 프로세스에 대해 큰 걱정할 필요는 없다.</div><div><br/></div><div>새로운 메세지가 도착하면, ROS가 당신의 콜백 함수를 실행하기 전까지는 일단 큐에 저장이 된다.</div><div>이 파라미터는 ROS가 한번에 그 큐에 저장할 수 있는 최대 메세지 갯수를 지정하기 위한 것이다.</div><div><br/></div><div>만약 큐가 꽉찬 상태에서 새로운 메세지가 도착하면, 처리되지 않은 메세지 중 가장 오래된 메세지부터 버리게 된다.</div><div>이 것은 표면적으로는 메세지를 <span style="color: rgb(222, 87, 0);">발행하는데 사용된 테크닉과 매우 유사</span>해 보인다.</div><div><span style="color: rgb(227, 0, 0);">그러나 매우 중요한 부분에서 차이</span>가 있다.</div><div>ROS가 <b>퍼블리싱 큐</b>를 비울 수 있는 속도는 실제로 <b>메세지를 구독자에게 전송하는데 걸리는 시간</b>에 달려 있다.</div><div>반면에, ROS가 <b>섭스크라이빙 큐</b>를 비우는 속도는 <b>우리가 얼마나 빨리 콜백을 처리하느냐</b>에 달려 있다.</div><div>그러므로, 우리는 구독자 큐의 오버플로우(차서 넘치는) 가능성을 낮추기 위해</div><div>(a) ros::spin이나 ros::spinOnce를 통해 콜백이 실행되도록 해주어야 하며,</div><div>(b) 각각의 콜백에서 소비하는 시간을 줄여야 한다.</div><div><br/></div><div><br/></div><div><span style="font-size: 19px;"><b>spin과 spinOnce</b></span></div><div><br/></div><div>ROS는 우리가 명시적으로 허락을 해줄 때만이 콜백 함수를 실행한다.</div><div>이를 위해 살짝 다른 두가지 방법이 존재한다.</div><div>하나는 ros::spinOnce()이다. 이 코드는 ROS에게 그 노드의 모든 구독에 대해 대기 중인 모든 콜백을 실행하도록 하고,</div><div>실행이 끝나면 우리에게 제어권을 돌려준다.</div><div>다른 하나는 ros::spin()이다. 이 코드는 ROS에게 노드가 셧다운될 때까지 콜백을 기다리면서 계속 실행하도록 한다.</div><div>ros::spinOnce()를 while(ros::ok())문에 넣고 계속 반복하는 것과 거의 같다.</div><div><br/></div><div>둘 중에 무엇을 사용할 것인가에 대한 질문은 이렇게 이어진다.</div><div><span style="color: rgb(227, 0, 0);">당신의 프로그램은 콜백에 대응하는 것 이외에 반복적으로 해야하는 작업이 있는가?</span></div><div>만약 대답이 No라면 ros::spin()을 사용할. 만약 대답이 yes라면 그 다른 작업을 수행하는 루프를 작성하고,</div><div>그 안에서 콜백을 호출하기 위한 ros::spinOnce()를 주기적으로 호출하라.</div><div><span style="color: rgb(222, 87, 0);">*구독을 위한 콜백을 기다림&amp;실행을 수행하면서 동시에 실시간으로 발행해야할 토픽이 있을 때도 역시 이와 같은 방법 사용.</span></div><div><span style="color: rgb(222, 87, 0);">*한마디로 완전히 콜백을 기다리는 것만 하는 경우가 아닌 이상 왠만하면 spinOnce를 쓰지 않을까..</span></div><div><i><span style="color: rgb(121, 121, 121);"><br/></span></i></div><div><i><span style="color: rgb(121, 121, 121);">구독자 프로그램의 흔한 오류는 실수로 두가지 스핀 방법을 모두 빼먹는 것이다.</span></i></div><div><i><span style="color: rgb(121, 121, 121);">이런 경우는 ROS는 절대 당신의 콜백함수를 실행할 기회를 가질 수 없다.</span></i></div><div><i><span style="color: rgb(121, 121, 121);">spin을 빼먹으면 프로그램이 시작하자마자 종료되어버릴 것이고,</span></i></div><div><i><span style="color: rgb(121, 121, 121);">spinOnce를 빼먹었다면 메세지를 받고 있지 않은 것처럼 보일 것이다.</span></i></div><div><i><span style="color: rgb(121, 121, 121);"><br/></span></i></div><div><i><span style="color: rgb(121, 121, 121);"><br/></span></i></div><div><hr/></div><div><i><span style="color: rgb(121, 121, 121);"><br/></span></i></div><div>고급 : 다른 콜백 큐 사용하기</div><div><br/></div><div>기본값으로, 모든 콜백은 글로벌 큐에 할당되고, 나중에 spin이나 spinOnce에 의해 처리된다.</div><div>roscpp는 사용자 커스텀 콜백 큐를 개별적으로 할당하고 실행할 수 있도록 한다.</div><div>이는 다음과 같이 세밀하게 컨트롤 할 수 있다.</div><div><br/></div><ol><li>subsribe(), advertise(), advertiseService() 등 마다 하나씩 큐 개별 할당</li><li>NodeHandle당 하나씩 큐 개별 할당</li></ol><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 