<html>
<head>
  <title>[Erle Robotics] Introduction to Networking in Linux</title>
  <basefont face="나눔고딕" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303244 (ko-KR, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 나눔고딕;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1559"/>
<h1>[Erle Robotics] Introduction to Networking in Linux</h1>

<div>
<span><div><b>What is Networking?</b></div><div><br/></div><div>네트워크상에서 복수의 머신(호스트)들은 sub-net에 연결되고, 이를 통해서 서로 대화한다.</div><div>기본적으로 두가지 방식으로 통신한다.</div><div><br/></div><div>- 포인트 투 포인트 채널을 통해서 (PPP)</div><div>- 브로드캐스트 채널을 통해서</div><div><br/></div><div>머신들이 서로 통신하려면 그들 자체로는 불가능하고, 중계해주는 머신인 '라우터'가 사용된다.</div><div>'프로토컬'은 통신을 하는 독립개체들이에 의해 공유되는 규칙의 집합(인터페이스, 알고리즘, 메세지 형식..)이다.</div><div><br/></div><div>프로토컬은 여러가지 레이어나 단계들로 조직화된다.</div><div>- 각각의 레이어는 상위 레벨에 서비스를 제공한다.</div><div>- 각각의 레이어는 하위 레벨4로부터 제공되는 서비스에 기반한다.</div><div><br/></div><div>하나의 머신에서 각각의 레벨은 또 다른 머신의 같은 레벨과 '이야기'를 나눈다.</div><div>이러한 '이야기'를 지배하는 규칙이 그 레벨의 프로토컬을 형성한다.</div><div><br/></div><div>프로토컬과 해당하는 레벨에 대한 몇가지 예시는 다음과 같다.</div><div><br/></div><table style="-evernote-table:true;border-collapse:collapse;table-layout:fixed;margin-left:0px;width:100%;"><tbody><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:50%;">레이어 이름</td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:50%;"><div><br/></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:50%;"><div>Application layer</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:50%;"><div>HTTP, DNS, SMTP, POP, ...</div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:50%;"><div>Transport layer</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:50%;"><div>TCP, UDP</div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:50%;"><div>Network layer</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:50%;"><div>IP, IPv6</div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:50%;"><div>Network access layer</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:50%;"><div>PPP, PPPoE, Ethernet</div></td></tr></tbody></table><div><br/></div><div>우리 네트워크 아키텍처를 논할때는, 컴퓨터 네트워크에 대한 레벨과 프로토컬의 집합에 대해 이야기하고 있는 것이다.</div><div><br/></div><div>리눅스 네트워킹</div><div><br/></div><div>다음 챕터로 가기 위해서 리눅스와 유닉스의 기본적인 지식을 갖추어야 한다. 그렇지 않다면 유닉스 입문 튜토리얼을 읽을 것을 추천한다.</div><div>알다시피, 리눅스 자체는 단순한 커널이다. 리눅스는 네트워크 워크스테이션으로써 설정될 수 있다.</div><div>예를 들면, DNS서버, DHCP서버, 웹서버, 메일서버, 파일/프린트 서버, 데이터베이스 서버, 방화벽, 게이트웨이 라우터 같은 것들이다.</div><div>리눅스로 이 모든 것들을 만들 수 있다. 이 섹션에서는 <span style="font-family:gotham, helvetica, arial, sans-serif;font-size:14px;">네트워크 운영체제나 서버 시스템으로써의 리눅스의 가능성을 배움으로써,</span></div><div>리눅스가 위에서 언급한 것들로 이용될 수 있도록 할 것이다.</div><div><br/></div><div>TCP와 패킷</div><div><br/></div><div>현대 네트워킹 어플리케이션은 하나의 머신에서 다른 머신으로 데이터를 옮기기위해서 세심한 접근을 필요로 한다.</div><div>유닉스 시스템과 그 후로 나온 많은 비유닉스 시스템을 이에 대한 해결책으로 TCP/IP를 채택했다.</div><div><br/></div><div>인터넷에서 통신하는 가장 인기있는 방법은 Transport Control Protocol(TCP)와 Internet Protocol(IP)이다.</div><div>당신의 브라우저와 이메일 프로그램과 같은 많은 어플리케이션은 이 프로토컬 묶음 위에서 만들어졌다.</div><div>(기억하라: 프로토컬이란 컴퓨터 안에서 혹은 컴퓨터 끼리 데이터를 교환하는 디지털 규칙이다.)</div><div><br/></div><div>TCP/IP 네트워크에 대하여 말할때 당신은 term datagram에 대해 듣게될 것이다. 이 용어는 기술적으로 특별한 의미가 있지만, 종종 패킷과 혼용해서 쓰인다.</div><div>아주 간단하게, IP는 하나의 머신에서 다른 머신으로 정보의 패킷을 보내는 솔루션을 제공하며,</div><div>TCP는 패킷들이 스트림 안에서 잘 정렬되어서 다른 어플리케이션에서 온 패킷과 섞이지 않고 올바른 순서로 보내고 받을 수 있도록 해준다.</div><div><br/></div><div>패킷이 실제로 어떻게 생겼는지에 대해 살펴보자. 각각의 패킷의 처음은 어디로 가고 어디서부터 오는지와 패킷의 타입, 그리고  다른 관리상의 정보를 말해준다.</div><div>이 부분을 '해킷 헤더'라고 부른다. 패킷의 나머지 부분은 전송되고 있는 실제 데이터를 포함하고 있으며 보통 '패킷 바디'라고 불린다.</div><div>- 어떤 IP 패킷이던지 'IP 헤더'로 시작한다 : 적어도 20바이트 길이를 갖는다.</div><div>- 만약 프로토컬 필드에서 현재 패킷이 TCP패킷임을 나타내고 있다면, TCP헤더가 즉시 IP헤더에 따라붙을 것이다. TCP 헤더 역시 적어도 20바이트의 길이.</div><div><br/></div><div>기본들 : 네트워킹의 첫 단계</div><div><br/></div><div>기본 명령어</div><div><br/></div><div>이 것은 네트워킹에서 가장 많이 사용되는 명령어 중 일부를 요약한 것이다.</div><div><br/></div><div>ifconfig</div><div>이 명령어는 네트워크 인터페이스 파라미터를 설정하거나 네트워크에 주소를 할당하도록 한다.</div><div><br/></div><div>netstat</div><div>network stauts. 이 명령어로 당신은 네트워크 연결목록을 확인할 수 있고 라우팅 테이블과 네트워크 인터페이스에 대한 게인 정보를 볼수 있다.</div><div>또한 netstat -r 명령은 라우팅 테이블을 보기 위해 자주 쓰인다.</div><div><br/></div><div>route</div><div>리눅스의 route 명령어는 IP 라우팅 테이블을 조작한다. route는 수동으로 네트워크 라우팅을 조작할 수 있는 유틸리티이다.</div><div><br/></div><div>ping</div><div>ICMP ECHO_REQUEST 패킷들을 네트워크를 네트워크 호스트로 보낸다.</div><div><br/></div><div>telnet</div><div>telnet 프로토컬을 사용하여 다른 호스트와 통신할 수 있도록 한다. 아마도 텔넷이 대부분의 유저들이 익숙한 용어중 하나일 것이다.</div><div>만약 telnet이 호스트 아규먼트 없이 호출된다면 자동으로 커맨드 모드로 진입하여 프롬프트에 &quot;telnet&gt;&quot;을 띄울 것이다.</div><div>이 모드에서 명령어를 받거나 실행한다.</div><div><br/></div><div>ftp</div><div>이 프로그램은 유저가 파일을 전송하거나 원격 네트워크 사이트로부터 전송 받도록한다. 인터넷 표준 File Transfer Protocol을 사용한다.</div><div><br/></div><div>arp</div><div>주소 resolution 프로토컬에 의해 사용되는 인터넷-to-이더넷 주소 변환 테이블을 보여주거나 편집할 수 있다.</div><div><br/></div><div>lsusb</div><div>시스템의 USB 버스나 거기에 연결된 장치들에 대한 정보를 보여준다. 이 프로그램의 모든 기능을 사용하기 위해서는 /proc/bus/usb 인터페이스를 지원하는</div><div>2.3.15 혹은 그 보다 상위 버전의 리눅스 커널이 필요하다.</div><div><br/></div><div>lsmod</div><div>모든 로드된 모듈에 대한 정보를 보여 준다. 형식은 이름, 사이즈, 사용 카운트, 참조하고 있는 모듈 리스트 등이다.</div><div>/proc/modules에서 볼 수 있는 정보와 동일하다.</div><div><br/></div><div>ip</div><div>IP는 인터넷 프로토컬 패밀리에 의해 사용되는 전송 레이어 프로토컬이다. TCP와 UDP와 같이 IP에 기반한 상위 레벨의 프로토컬을 사용할 때는</div><div>IP레벨에서 옵션을 설정할 수 있다. 새로운 프로토컬이나 특별한 목적의 어플리케이션을 개발할 때는 &quot;raw socket&quot;을 통해 IP 엑세스가 가능하다.</div><div>이 명령어를 통해 IP 주소나 IP route를 볼 수 있다.</div><div><br/></div><div>traceroute</div><div>네트워크 호스트에 대해 루트 패킷 사용량을 보여준다. IP프로토컬의 &quot;time to live&quot;필드를 활용한다.</div><div>하나의 패킷이 호스트까지 가는 경로의 각각의 게이트웨이로부터 ICMP TIME_EXCEEDED 반응을 이끌어낸다.</div><div><br/></div><div>whois</div><div>특정한 도메인 이름 정보를 보여준다. 이 유틸리티는 몇가지 네트워크 정보 센터들(NICs)로부터 유지되는 데이터베이스의 기록을 대조하여</div><div>인터넷 도메인 이름과 네트워크 번호 디렉토리 서비스를 디스플레이해준다.</div><div><br/></div><div>sudo</div><div>슈퍼유저나 sudoers 파일에 특정되어 있는 다른 유저의 권한으로 명령을 실행할 수 있도록 해줌. 호출한 유저가 root이거나 타겟유저와 호출유저가 동일할 때는</div><div>비밀번호가 필요없지만 그렇지 않으면 인증을 위한 비밀번호가 기본으로 필요하다. (단, 루트 비밀번호가 아닌, 그 유저의 비밀번호가 기본값으로 설정)</div><div>한번 인증이되면, 시간 스탬프가 업데이트되고 5분동안만 비밀번호없이 사용가능함.</div><div><br/></div><div><b>IP address</b></div><div><br/></div><div>이 섹션에서 당신은 IP 프로토컬과 IP 주소와 연관되어 있는 기본적 개념을 알아볼 것이다.</div><div><br/></div><div>기본 개념</div><div><br/></div><div>네트워크에서 가장 먼저 배워야 할 것은 IP 프로토컬과 IP 주소이다.</div><div><br/></div><div>IP 프로토컬은 네트워킹이 가능하게 하는 프로토컬 중의 하나다. 프토토컬이 두 시스템 사이의 커뮤니케이션을 통제하는 규칙이라는 것을 기억하라.</div><div>IP는 Network 레벨에서의 프로토컬이며, 다음 패턴을 따른다.</div><div><br/></div><div>- 연결을 지향하지 않음 : 연결을 확립하는 단계 없이도 보낼 데이터가 있으면 언제든지 전송.</div><div>- 데이터그램 기반 : 각각의 메세지는 목적지로 분산되어 보내어진다. <span style="font-family:gotham, helvetica, arial, sans-serif;font-size:14px;">IP에 의해 보내진 </span>데이터의 단위를 IP 데이터그램이라고 부른다.</div><div><br/></div><div>IP 프로토컬을 이야기할때 우리는 다음 주제인 IP어드레스에 대해서 알아야 한다. IP 주소는 하나의 네트워크 컴퓨터에 할당된 고유 주소이다.</div><div>서버에 통신을 요청하는 클라이언트의 상황과 같이 네트워크 컴퓨터는 자신이 어떤 컴퓨터가 통신하는지 알아야만 하므로 IP주소가 필요하게 된다.</div><div>그러므로 IP주소는 인터넷에 접속된 각각의 물리적 기계에 대하여 할당된다.</div><div><br/></div><div>IP 주소는 32바이트이고 두 개의 파트로 나누어 진다.</div><div>- 네트워크 식별자 / 네트워크 접두어 : 머신이 접속되어 있는 네트워크를 구분해주는 바이트 집합</div><div>- 머신 식별자 / 호스트 접두어 : 네트워크 내부의 각각의 머신에 대한 고유 바이트 집합</div><div><br/></div><div><img src="[Erle Robotics] Introduction to Networking in_files/Image.png" type="image/png" alt="prefix" style="height: auto;"/></div><div><br/></div><div>예를 들어, IP 주소가 다음과 같을 때 : 212.128.4.4</div><div>네트워크 식별자 : 212.128.4</div><div>머신 식별자 : 4</div><div><br/></div><div>IP주소는 5개의 클래스로 나누어진다. 처음의 3개의  클래스만 머신에 할당된다. (클래스 A, 클래스 B, 클래스 C)</div><div>각각의 클래스에서 식별자의 범위와 사이즈는 다르다.</div><div><img src="[Erle Robotics] Introduction to Networking in_files/Image.jpg" type="image/jpeg" style="height: auto;"/></div><div>다음은 서브넷마스크이다. IP 주소를 네트워크 컴퓨터에 할당할 때마다, 우리는 반드시 서브넷마스크도 함께 할당한다.</div><div>IP 주소는 그 클래스에 따라서 다른 서브넷마스크와 함께 온다. <span style="font-family:gotham, helvetica, arial, sans-serif;font-size:14px;">서브넷 마스크는</span> 각각의 IP 클래스에서 그 시스템의 네트워크 세그멘트를 정의한다.</div><div>이는 서브넷마스크가 네트워크를 위해서 얼마만큼의 주소를 할당할지를 결정한다는 의미다.</div><div>서브넷마스크는 사용되는 네트워크와 서브네트워크를 특정하기 위해 존재한다.</div><div><br/></div><div>기본 서브넷 마스크</div><div>A - 255.0.0.0</div><div>B - 255.255.0.0</div><div>C - 255.255.255.0</div><div><br/></div><div>넷마스크는 게이트웨이의 개념이다. 게이트웨이는 로컬 네트워크와 외부 네트워크의 경계점을 정의하는 IP address이다.</div><div>다시 말해서, 게이트웨이는 두 개 이상의 물리적 네트워크가 동시적으로 연결되어서 그들 사이의 패킷을 스위칭하는 호스트이다.</div><div>이때, 게이트웨이 IP 주소는 공공 인터넷처럼 로컬 네트워크의 일부이다.</div><div>게이트웨이 IP 주소는 보통 로컬 시스템의 routing table에 설정되어 있으며, route나 netstat -r 명령어를 통해 정의할 수 있다.</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 